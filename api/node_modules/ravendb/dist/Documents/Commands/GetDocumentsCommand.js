"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RavenCommand_1 = require("../../Http/RavenCommand");
const HttpUtil_1 = require("../../Utility/HttpUtil");
const ObjectMapper_1 = require("../../Mapping/ObjectMapper");
const TypeUtil_1 = require("../../Utility/TypeUtil");
const Serializer_1 = require("../../Mapping/Json/Serializer");
class GetDocumentsCommand extends RavenCommand_1.RavenCommand {
    constructor(opts) {
        super();
        if (opts.hasOwnProperty("id")) {
            opts = opts;
            this._id = opts.id;
            this._includes = opts.includes;
            this._metadataOnly = opts.metadataOnly;
        }
        else if (opts.hasOwnProperty("ids")) {
            opts = opts;
            this._ids = opts.ids;
            this._includes = opts.includes;
            this._metadataOnly = opts.metadataOnly;
        }
        else if (opts.hasOwnProperty("start") && opts.hasOwnProperty("pageSize")) {
            opts = opts;
            this._start = opts.start;
            this._pageSize = opts.pageSize;
            if (opts.hasOwnProperty("startsWith")) {
                this._startsWith = opts.startsWith;
                this._startAfter = opts.startsAfter;
                this._matches = opts.matches;
                this._exclude = opts.exclude;
                this._metadataOnly = opts.metadataOnly;
            }
        }
    }
    createRequest(node) {
        const uriPath = `${node.url}/databases/${node.database}/docs?`;
        let query = "";
        if (!TypeUtil_1.TypeUtil.isNullOrUndefined(this._start)) {
            query += `&start=${this._start}`;
        }
        if (this._pageSize) {
            query += `&pageSize=${this._pageSize}`;
        }
        if (this._metadataOnly) {
            query += "&metadataOnly=true";
        }
        if (this._startsWith) {
            query += `&startsWith=${encodeURIComponent(this._startsWith)}`;
            if (this._matches) {
                query += `&matches=${this._matches}`;
            }
            if (this._exclude) {
                query += `&exclude=${this._exclude}`;
            }
            if (this._startAfter) {
                query += `&startAfter=${this._startAfter}`;
            }
        }
        if (this._includes) {
            for (const include of this._includes) {
                query += `&include=${include}`;
            }
        }
        let request = { method: "GET", uri: uriPath + query };
        if (this._id) {
            request.uri += `&id=${encodeURIComponent(this._id)}`;
        }
        else if (this._ids) {
            request = this.prepareRequestWithMultipleIds(request, this._ids);
        }
        return request;
    }
    prepareRequestWithMultipleIds(request, ids) {
        const uniqueIds = new Set(ids);
        const isGet = Array.from(uniqueIds)
            .map(x => x.length)
            .reduce((result, next) => result + next, 0) < 1024;
        let newUri = request.uri;
        if (isGet) {
            uniqueIds.forEach(x => {
                if (x) {
                    newUri += `&id=${encodeURIComponent(x)}`;
                }
            });
            return { method: "GET", uri: newUri };
        }
        else {
            const body = this._serializer
                .serialize({ ids: [...uniqueIds] });
            return {
                uri: newUri,
                method: "POST",
                headers: HttpUtil_1.getHeaders()
                    .withContentTypeJson()
                    .build(),
                body
            };
        }
    }
    get _serializer() {
        const serializer = super._serializer;
        return serializer;
    }
    setResponse(response, fromCache) {
        if (!response) {
            this.result = null;
            return;
        }
        const raw = Serializer_1.JsonSerializer.getDefault().deserialize(response);
        this.result = ObjectMapper_1.ObjectKeysTransform.camelCase(raw);
    }
    get isReadRequest() {
        return true;
    }
}
exports.GetDocumentsCommand = GetDocumentsCommand;
