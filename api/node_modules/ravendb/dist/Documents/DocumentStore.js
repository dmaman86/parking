"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("uuid");
const BluebirdPromise = require("bluebird");
const Exceptions_1 = require("../Exceptions");
const RequestExecutor_1 = require("../Http/RequestExecutor");
const LogUtil_1 = require("../Utility/LogUtil");
const DocumentStoreBase_1 = require("./DocumentStoreBase");
const MaintenanceOperationExecutor_1 = require("./Operations/MaintenanceOperationExecutor");
const OperationExecutor_1 = require("./Operations/OperationExecutor");
const DocumentSession_1 = require("./Session/DocumentSession");
const HiloMultiDatabaseIdGenerator_1 = require("./Identity/HiloMultiDatabaseIdGenerator");
const log = LogUtil_1.getLogger({ module: "DocumentStore" });
class DocumentStore extends DocumentStoreBase_1.DocumentStoreBase {
    constructor(urls, database, authOptions) {
        super();
        this._log = LogUtil_1.getLogger({ module: "DocumentStore-" + Math.floor(Math.random() * 1000) });
        this._requestExecutors = new Map();
        this._database = database;
        this.authOptions = authOptions;
        this.urls = Array.isArray(urls)
            ? urls
            : [urls];
    }
    get identifier() {
        if (this._identifier) {
            return this._identifier;
        }
        if (!this._urls) {
            return null;
        }
        const urlsString = this._urls.join(", ");
        if (this._database) {
            return `${urlsString} DB: ${this._database}`;
        }
        return urlsString;
    }
    set identifier(identifier) {
        this.identifier = identifier;
    }
    dispose() {
        this._log.info("Dispose.");
        this.emit("beforeDispose");
        const disposeChain = BluebirdPromise.resolve();
        disposeChain
            .then(() => {
            if (this._multiDbHiLo) {
                return BluebirdPromise.resolve()
                    .then(() => this._multiDbHiLo.returnUnusedRange())
                    .catch(err => this._log.warn("Error returning unused ID range.", err));
            }
        })
            .then(() => {
            this._disposed = true;
            return new BluebirdPromise((resolve, reject) => {
                let listenersExecCallbacksCount = 0;
                const listenersCount = this.listenerCount("afterDispose");
                this.emit("afterDispose", () => {
                    if (listenersCount === ++listenersExecCallbacksCount) {
                        resolve();
                    }
                });
            })
                .timeout(5000)
                .catch((err) => this._log.warn(`Error handling 'afterDispose'`, err));
        })
            .then(() => {
            this._log.info(`Disposing request executors ${this._requestExecutors.size}`);
            this._requestExecutors.forEach((executor, db) => {
                try {
                    executor.dispose();
                }
                catch (err) {
                    this._log.warn(err, `Error disposing request executor.`);
                }
            });
        })
            .finally(() => this.emit("executorsDisposed"));
    }
    openSession(databaseOrSessionOptions) {
        this._assertInitialized();
        this._ensureNotDisposed();
        if (typeof (databaseOrSessionOptions) === "string") {
            return this.openSession({
                database: databaseOrSessionOptions
            });
        }
        let database;
        let sessionOpts;
        let requestExecutor;
        databaseOrSessionOptions = databaseOrSessionOptions || {};
        database = databaseOrSessionOptions.database || this._database;
        sessionOpts = databaseOrSessionOptions;
        requestExecutor = sessionOpts.requestExecutor || this.getRequestExecutor(database);
        const sessionId = uuid();
        const session = new DocumentSession_1.DocumentSession(database, this, sessionId, requestExecutor);
        this._registerEvents(session);
        return session;
    }
    getRequestExecutor(database) {
        this._assertInitialized();
        if (!database) {
            database = this.database;
        }
        const databaseLower = database.toLowerCase();
        let executor = this._requestExecutors.get(databaseLower);
        if (executor) {
            return executor;
        }
        if (!this.conventions.disableTopologyUpdates) {
            executor = RequestExecutor_1.RequestExecutor.create(this.urls, database, {
                authOptions: this.authOptions,
                documentConventions: this.conventions
            });
        }
        else {
            executor = RequestExecutor_1.RequestExecutor.createForSingleNodeWithConfigurationUpdates(this.urls[0], database, {
                authOptions: this.authOptions,
                documentConventions: this.conventions
            });
        }
        this._log.info(`New request executor for datebase ${database}`);
        this._requestExecutors.set(databaseLower, executor);
        return executor;
    }
    initialize() {
        if (this._initialized) {
            return this;
        }
        this._assertValidConfiguration();
        try {
            if (!this.conventions.documentIdGenerator) {
                const generator = new HiloMultiDatabaseIdGenerator_1.HiloMultiDatabaseIdGenerator(this);
                this._multiDbHiLo = generator;
                this.conventions.documentIdGenerator =
                    (dbName, entity) => generator.generateDocumentId(dbName, entity);
            }
            this.conventions.freeze();
            this._initialized = true;
        }
        catch (e) {
            this.dispose();
            throw e;
        }
        return this;
    }
    _assertValidConfiguration() {
        if (!this._urls || !this._urls.length) {
            Exceptions_1.throwError("InvalidArgumentException", "Document store URLs cannot be empty");
        }
    }
    disableAggressiveCaching(database) {
        this._assertInitialized();
        const re = this.getRequestExecutor(database || this.database);
        const old = re.agressiveCaching;
        re.agressiveCaching = null;
        const dispose = () => re.agressiveCaching = old;
        return { dispose };
    }
    get maintenance() {
        this._assertInitialized();
        if (!this._maintenanceOperationExecutor) {
            this._maintenanceOperationExecutor = new MaintenanceOperationExecutor_1.MaintenanceOperationExecutor(this);
        }
        return this._maintenanceOperationExecutor;
    }
    get operations() {
        if (!this._operationExecutor) {
            this._operationExecutor = new OperationExecutor_1.OperationExecutor(this);
        }
        return this._operationExecutor;
    }
}
exports.DocumentStore = DocumentStore;
