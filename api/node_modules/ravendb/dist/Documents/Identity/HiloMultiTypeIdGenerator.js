"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const HiloIdGenerator_1 = require("./HiloIdGenerator");
const AbstractHiloIdGenerator_1 = require("./AbstractHiloIdGenerator");
const semaphore = require("semaphore");
const BluebirdPromise = require("bluebird");
const SemaphoreUtil_1 = require("../../Utility/SemaphoreUtil");
class HiloMultiTypeIdGenerator extends AbstractHiloIdGenerator_1.AbstractHiloIdGenerator {
    constructor(store, dbName) {
        super(store, dbName);
        this._sem = semaphore();
    }
    generateDocumentId(entity, documentType) {
        const entityType = this._conventions.findEntityType(documentType);
        const typeTagName = entityType
            ? this._conventions.getCollectionNameForType(entityType)
            : this._conventions.getCollectionNameForEntity(entity);
        if (!typeTagName) {
            return Promise.resolve(null);
        }
        return Promise.resolve()
            .then(() => this._conventions.transformClassCollectionNameToDocumentIdPrefix(typeTagName))
            .then(tag => this._createGeneratorForTag(tag))
            .then((generator) => generator.generateDocumentId());
    }
    _createGeneratorForTag(tag) {
        const acquiredSem = SemaphoreUtil_1.acquireSemaphore(this._sem);
        const result = BluebirdPromise.resolve(acquiredSem.promise)
            .then(() => {
            let generator = this._generators[tag];
            if (!generator) {
                generator = this._generators[tag] =
                    new HiloIdGenerator_1.HiloIdGenerator(this._store, this._dbName, tag);
            }
            return generator;
        })
            .finally(() => acquiredSem.dispose());
        return Promise.resolve(result);
    }
}
exports.HiloMultiTypeIdGenerator = HiloMultiTypeIdGenerator;
