"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../../Exceptions/index");
const IndexFieldOptions_1 = require("./IndexFieldOptions");
class IndexDefinition {
    constructor() {
        this.additionalSources = {};
        this.maps = new Set();
        this.fields = {};
        this.configuration = {};
    }
    toString() {
        return this.name;
    }
    get type() {
        if (!this.indexType || this.indexType === "None") {
            this.indexType = this._detectStaticIndexType();
        }
        return this.indexType;
    }
    set type(indexType) {
        this.indexType = indexType;
    }
    _detectStaticIndexType() {
        if (!this.reduce) {
            return "Map";
        }
        return "MapReduce";
    }
}
exports.IndexDefinition = IndexDefinition;
class IndexDefinitionBuilder {
    constructor(indexName) {
        this.indexName = indexName || this.constructor.name;
        this.storesStrings = {};
        this.indexesStrings = {};
        this.suggestionsOptions = new Set();
        this.analyzersStrings = {};
        this.termVectorsStrings = {};
        this.spatialIndexesStrings = {};
    }
    toIndexDefinition(conventions, validateMap) {
        if (!this.map && validateMap) {
            index_1.throwError("InvalidOperationException", "Map is required to generate an index, "
                + " you cannot create an index without a valid Map property (in index "
                + this.indexName + ").");
        }
        try {
            const indexDefinition = new IndexDefinition();
            indexDefinition.name = this.indexName;
            indexDefinition.reduce = this.reduce;
            indexDefinition.lockMode = this.lockMode;
            indexDefinition.priority = this.priority;
            indexDefinition.outputReduceToCollection = this.outputReduceToCollection;
            const suggestions = Array.from(this.suggestionsOptions)
                .reduce((result, item) => Object.assign(result, { [item]: true }), {});
            this._applyValues(indexDefinition, this.indexesStrings, (options, value) => options.indexing = value);
            this._applyValues(indexDefinition, this.storesStrings, (options, value) => options.storage = value);
            this._applyValues(indexDefinition, this.analyzersStrings, (options, value) => options.analyzer = value);
            this._applyValues(indexDefinition, this.termVectorsStrings, (options, value) => options.termVector = value);
            this._applyValues(indexDefinition, this.spatialIndexesStrings, (options, value) => options.spatial = value);
            this._applyValues(indexDefinition, suggestions, (options, value) => options.suggestions = value);
            if (this.map) {
                indexDefinition.maps.add(this.map);
            }
            indexDefinition.additionalSources = this.additionalSources;
            return indexDefinition;
        }
        catch (err) {
            index_1.throwError("IndexCompilationException", "Failed to create index " + this.indexName, err);
        }
    }
    _applyValues(indexDefinition, values, action) {
        for (const fieldName of Object.keys(values)) {
            const fieldVal = values[fieldName];
            const field = indexDefinition.fields[fieldName] =
                indexDefinition.fields[fieldName] || new IndexFieldOptions_1.IndexFieldOptions();
            action(field, fieldVal);
        }
    }
}
exports.IndexDefinitionBuilder = IndexDefinitionBuilder;
