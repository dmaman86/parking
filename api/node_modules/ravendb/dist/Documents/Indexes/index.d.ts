import { FieldStorage, FieldIndexing, FieldTermVector, IndexPriority, IndexLockMode } from "./Enums";
import { SpatialOptions, SpatialOptionsFactory } from "./Spatial";
import { DocumentConventions } from "../Conventions/DocumentConventions";
import { IndexDefinition } from "./IndexDefinition";
import { IDocumentStore } from "../IDocumentStore";
export declare abstract class AbstractIndexCreationTask {
    protected map: string;
    protected reduce: string;
    conventions: DocumentConventions;
    protected additionalSources: {
        [key: string]: string;
    };
    priority: IndexPriority;
    lockMode: IndexLockMode;
    protected storesStrings: {
        [key: string]: FieldStorage;
    };
    protected indexesStrings: {
        [key: string]: FieldIndexing;
    };
    protected analyzersStrings: {
        [key: string]: string;
    };
    protected indexSuggestions: Set<string>;
    protected termVectorsStrings: {
        [key: string]: FieldTermVector;
    };
    protected spatialOptionsStrings: {
        [key: string]: SpatialOptions;
    };
    protected outputReduceToCollection: string;
    constructor();
    createIndexDefinition(): IndexDefinition;
    readonly isMapReduce: boolean;
    getIndexName(): string;
    execute(store: IDocumentStore, conventions?: DocumentConventions, database?: string): Promise<void>;
    private _putIndex(store, conventions, database);
    protected index(field: string, indexing: FieldIndexing): void;
    protected spatial(field: string, indexing: (spatialOptsFactory: SpatialOptionsFactory) => SpatialOptions): void;
    protected storeAllFields(storage: FieldStorage): void;
    protected store(field: string, storage: FieldStorage): void;
    protected analyze(field: string, analyzer: string): void;
    protected termVector(field: string, termVector: FieldTermVector): void;
    protected suggestion(field: string): void;
}
