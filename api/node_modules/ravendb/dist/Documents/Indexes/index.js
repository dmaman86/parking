"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BluebirdPromise = require("bluebird");
const Spatial_1 = require("./Spatial");
const DocumentConventions_1 = require("../Conventions/DocumentConventions");
const IndexDefinition_1 = require("./IndexDefinition");
const Constants_1 = require("../../Constants");
const PutIndexesOperation_1 = require("../Operations/Indexes/PutIndexesOperation");
class AbstractIndexCreationTask {
    constructor() {
        this.storesStrings = {};
        this.indexesStrings = {};
        this.analyzersStrings = {};
        this.indexSuggestions = new Set();
        this.termVectorsStrings = {};
        this.spatialOptionsStrings = {};
    }
    createIndexDefinition() {
        if (!this.conventions) {
            this.conventions = new DocumentConventions_1.DocumentConventions();
        }
        const indexDefinitionBuilder = new IndexDefinition_1.IndexDefinitionBuilder(this.getIndexName());
        indexDefinitionBuilder.indexesStrings = this.indexesStrings;
        indexDefinitionBuilder.analyzersStrings = this.analyzersStrings;
        indexDefinitionBuilder.map = this.map;
        indexDefinitionBuilder.reduce = this.reduce;
        indexDefinitionBuilder.storesStrings = this.storesStrings;
        indexDefinitionBuilder.suggestionsOptions = this.indexSuggestions;
        indexDefinitionBuilder.termVectorsStrings = this.termVectorsStrings;
        indexDefinitionBuilder.spatialIndexesStrings = this.spatialOptionsStrings;
        indexDefinitionBuilder.outputReduceToCollection = this.outputReduceToCollection;
        indexDefinitionBuilder.additionalSources = this.additionalSources;
        return indexDefinitionBuilder.toIndexDefinition(this.conventions);
    }
    get isMapReduce() {
        return !!this.reduce;
    }
    getIndexName() {
        return this.constructor.name.replace(/_/g, "/");
    }
    execute(store, conventions, database) {
        return Promise.resolve()
            .then(() => {
            if (!conventions && !database) {
                return store.executeIndex(this);
            }
            else {
                return this._putIndex(store, conventions, database);
            }
        });
    }
    _putIndex(store, conventions, database) {
        const oldConventions = this.conventions;
        const result = BluebirdPromise.resolve()
            .then(() => {
            this.conventions = conventions || this.conventions || store.conventions;
            const indexDefinition = this.createIndexDefinition();
            indexDefinition.name = this.getIndexName();
            if (this.lockMode) {
                indexDefinition.lockMode = this.lockMode;
            }
            if (this.priority) {
                indexDefinition.priority = this.priority;
            }
            return store.maintenance.forDatabase(database || store.database)
                .send(new PutIndexesOperation_1.PutIndexesOperation(indexDefinition))
                .then(() => { return; });
        })
            .finally(() => this.conventions = oldConventions);
        return Promise.resolve(result);
    }
    index(field, indexing) {
        this.indexesStrings[field] = indexing;
    }
    spatial(field, indexing) {
        this.spatialOptionsStrings[field] = indexing(new Spatial_1.SpatialOptionsFactory());
    }
    storeAllFields(storage) {
        this.storesStrings[Constants_1.CONSTANTS.Documents.Indexing.Fields.ALL_FIELDS] = storage;
    }
    store(field, storage) {
        this.storesStrings[field] = storage;
    }
    analyze(field, analyzer) {
        this.analyzersStrings[field] = analyzer;
    }
    termVector(field, termVector) {
        this.termVectorsStrings[field] = termVector;
    }
    suggestion(field) {
        this.indexSuggestions.add(field);
    }
}
exports.AbstractIndexCreationTask = AbstractIndexCreationTask;
