/// <reference types="node" />
import { QueryOperation } from "./Operations/QueryOperation";
import { FieldsToFetchToken } from "./Tokens/FieldsToFetchToken";
import { DeclareToken } from "./Tokens/DeclareToken";
import { LoadToken } from "./Tokens/LoadToken";
import { FromToken } from "./Tokens/FromToken";
import { InMemoryDocumentSessionOperations } from "./InMemoryDocumentSessionOperations";
import { QueryStatistics } from "./QueryStatistics";
import { IDocumentSession } from "./IDocumentSession";
import { QueryOperator } from "../Queries/QueryOperator";
import { IndexQuery } from "../Queries/IndexQuery";
import { IAbstractDocumentQuery } from "./IAbstractDocumentQuery";
import { GroupBy } from "../Queries/GroupBy";
import { QueryToken } from "./Tokens/QueryToken";
import { WhereParams } from "./WhereParams";
import { MethodCall } from "./MethodCall";
import { QueryResult } from "../Queries/QueryResult";
import { DocumentType } from "../DocumentAbstractions";
import { QueryEventsEmitter } from "./QueryEvents";
import { EventEmitter } from "events";
import { DocumentConventions } from "../Conventions/DocumentConventions";
import { OrderingType } from "./OrderingType";
import { SearchOperator } from "../Queries/SearchOperator";
import { SpatialUnits, SpatialRelation } from "../Indexes/Spatial";
import { DynamicSpatialField } from "../Queries/Spatial/DynamicSpatialField";
import { SpatialCriteria } from "../Queries/Spatial/SpatialCriteria";
import { AbstractCallback } from "../../Types/Callbacks";
export declare abstract class AbstractDocumentQuery<T extends object, TSelf extends AbstractDocumentQuery<T, TSelf>> extends EventEmitter implements QueryEventsEmitter, IAbstractDocumentQuery<T> {
    protected _clazz: DocumentType<T>;
    private _aliasToGroupByFieldName;
    protected _defaultOperator: QueryOperator;
    protected _rootTypes: Set<DocumentType>;
    protected _negate: boolean;
    private _indexName;
    private _collectionName;
    private _currentClauseDepth;
    protected _queryRaw: string;
    readonly indexName: string;
    readonly collectionName: string;
    protected _queryParameters: {
        [key: string]: object;
    };
    protected _isIntersect: boolean;
    protected _isGroupBy: boolean;
    protected _theSession: InMemoryDocumentSessionOperations;
    protected _pageSize: number;
    protected _selectTokens: QueryToken[];
    protected _fromToken: FromToken;
    protected _declareToken: DeclareToken;
    protected _loadTokens: LoadToken[];
    protected _fieldsToFetchToken: FieldsToFetchToken;
    protected _whereTokens: QueryToken[];
    protected _groupByTokens: QueryToken[];
    protected _orderByTokens: QueryToken[];
    protected _start: number;
    private _conventions;
    protected _timeout: number;
    protected _theWaitForNonStaleResults: boolean;
    protected _includes: Set<string>;
    private _statsCallback;
    protected _queryStats: QueryStatistics;
    protected _disableEntitiesTracking: boolean;
    protected _disableCaching: boolean;
    readonly isDistinct: boolean;
    readonly conventions: DocumentConventions;
    readonly session: IDocumentSession;
    isDynamicMapReduce(): boolean;
    private _isInMoreLikeThis;
    private static _getDefaultTimeout();
    protected constructor(clazz: DocumentType<T>, session: InMemoryDocumentSessionOperations, indexName: string, collectionName: string, isGroupBy: boolean, declareToken: DeclareToken, loadTokens: LoadToken[]);
    protected constructor(clazz: DocumentType<T>, session: InMemoryDocumentSessionOperations, indexName: string, collectionName: string, isGroupBy: boolean, declareToken: DeclareToken, loadTokens: LoadToken[], fromAlias: string);
    private _getCurrentWhereTokens();
    private _ensureValidFieldName(fieldName, isNestedPath);
    private _appendOperatorIfNeeded(tokens);
    private _transformCollection(fieldName, values);
    private _negateIfNeeded(tokens, fieldName);
    _usingDefaultOperator(operator: any): void;
    _waitForNonStaleResults(waitTimeout: number): void;
    protected _initializeQueryOperation(): QueryOperation;
    private _transformValue(whereParams);
    private _transformValue(whereParams, forRange);
    private _addQueryParameter(value);
    protected _updateFieldsToFetchToken(fieldsToFetch: FieldsToFetchToken): void;
    getIndexQuery(): IndexQuery;
    getProjectionFields(): string[];
    _randomOrdering(): void;
    _randomOrdering(seed?: string): void;
    protected addGroupByAlias(fieldName: string, projectedName: string): void;
    private _assertNoRawQuery();
    addParameter(name: string, value: any): void;
    _groupBy(fieldName: string, ...fieldNames: string[]): void;
    _groupBy(field: GroupBy, ...fields: GroupBy[]): void;
    _groupByKey(fieldName: string): void;
    _groupByKey(fieldName: string, projectedName: string): void;
    _groupBySum(fieldName: string): void;
    _groupBySum(fieldName: string, projectedName: string): void;
    _groupByCount(): void;
    _groupByCount(projectedName: string): void;
    _whereTrue(): void;
    _include(path: string): void;
    _take(count: number): void;
    _skip(count: number): void;
    _whereLucene(fieldName: string, whereClause: string): void;
    _openSubclause(): void;
    _closeSubclause(): void;
    _whereEquals(fieldName: string, method: MethodCall): void;
    _whereEquals(fieldName: string, method: MethodCall, exact: boolean): void;
    _whereEquals(fieldName: string, value: any): void;
    _whereEquals(fieldName: string, value: any, exact: boolean): void;
    _whereEquals(whereParams: WhereParams): void;
    private _ifValueIsMethod(op, whereParams, tokens);
    _whereNotEquals(fieldName: string, value: any): void;
    _whereNotEquals(fieldName: string, value: any, exact: boolean): void;
    _whereNotEquals(fieldName: string, method: MethodCall): void;
    _whereNotEquals(fieldName: string, method: MethodCall, exact: boolean): void;
    _whereNotEquals(whereParams: WhereParams): void;
    negateNext(): void;
    _whereIn(fieldName: string, values: any[]): void;
    _whereIn(fieldName: string, values: any[], exact: boolean): void;
    _whereStartsWith(fieldName: string, value: any): void;
    _whereEndsWith(fieldName: string, value: any): void;
    _whereBetween(fieldName: string, start: any, end: any): void;
    _whereBetween(fieldName: string, start: any, end: any, exact: boolean): void;
    _whereGreaterThan(fieldName: string, value: any): void;
    _whereGreaterThan(fieldName: string, value: any, exact: boolean): void;
    _whereGreaterThanOrEqual(fieldName: string, value: any): void;
    _whereGreaterThanOrEqual(fieldName: string, value: any, exact: boolean): void;
    _whereLessThan(fieldName: string, value: any): void;
    _whereLessThan(fieldName: string, value: any, exact: boolean): void;
    _whereLessThanOrEqual(fieldName: string, value: any): void;
    _whereLessThanOrEqual(fieldName: string, value: any, exact: boolean): void;
    _whereRegex(fieldName: string, pattern: string): void;
    _andAlso(): void;
    _orElse(): void;
    _boost(boost: number): void;
    _fuzzy(fuzzy: number): void;
    _proximity(proximity: number): void;
    _orderBy(field: string): void;
    _orderBy(field: string, ordering: OrderingType): void;
    _orderByDescending(field: string): void;
    _orderByDescending(field: string, ordering: OrderingType): void;
    _orderByScore(): void;
    _orderByScoreDescending(): void;
    _statistics(statsCallback: (stats: QueryStatistics) => void): void;
    protected _generateIndexQuery(query: string): IndexQuery;
    _search(fieldName: string, searchTerms: string): void;
    _search(fieldName: string, searchTerms: string, operator: SearchOperator): void;
    toString(): string;
    private _buildInclude(queryText);
    _intersect(): void;
    _whereExists(fieldName: string): void;
    _containsAny(fieldName: string, values: any[]): void;
    _containsAll(fieldName: string, values: any[]): void;
    addRootType(clazz: DocumentType): void;
    _distinct(): void;
    private _updateStatsAndHighlightings(queryResult);
    private _buildSelect(writer);
    private _buildFrom(writer);
    private _buildDeclare(writer);
    private _buildLoad(writer);
    private _buildWhere(writer);
    private _buildGroupBy(writer);
    private _buildOrderBy(writer);
    private static _unpackCollection(items);
    protected _queryOperation: QueryOperation;
    queryOperation(): QueryOperation;
    _noTracking(): void;
    _noCaching(): void;
    protected _withinRadiusOf(fieldName: string, radius: number, latitude: number, longitude: number, radiusUnits: SpatialUnits, distErrorPercent: number): void;
    protected _spatialByShapeWkt(fieldName: string, shapeWkt: string, relation: SpatialRelation, distErrorPercent: number): void;
    _spatial(dynamicField: DynamicSpatialField, criteria: SpatialCriteria): void;
    _spatial(fieldName: string, criteria: SpatialCriteria): void;
    _orderByDistance(field: DynamicSpatialField, latitude: number, longitude: number): void;
    _orderByDistance(field: DynamicSpatialField, shapeWkt: string): void;
    _orderByDistance(fieldName: string, latitude: number, longitude: number): void;
    _orderByDistance(fieldName: string, shapeWkt: string): void;
    _orderByDistanceDescending(field: DynamicSpatialField, latitude: number, longitude: number): void;
    _orderByDistanceDescending(field: DynamicSpatialField, shapeWkt: string): void;
    _orderByDistanceDescending(fieldName: string, latitude: number, longitude: number): void;
    _orderByDistanceDescending(fieldName: string, shapeWkt: string): void;
    protected _initSync(): Promise<void>;
    private _executeActualQuery();
    iterator(): Promise<IterableIterator<T>>;
    all(callback?: AbstractCallback<T[]>): Promise<T[]>;
    getQueryResult(): Promise<QueryResult>;
    first(callback?: AbstractCallback<T>): Promise<T>;
    single(callback?: AbstractCallback<T>): Promise<T>;
    count(callback?: AbstractCallback<number>): Promise<number>;
    private _executeQueryOperation(take);
}
