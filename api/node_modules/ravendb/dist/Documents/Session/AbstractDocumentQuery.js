"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const QueryOperation_1 = require("./Operations/QueryOperation");
const BluebirdPromise = require("bluebird");
const GroupByCountToken_1 = require("./Tokens/GroupByCountToken");
const GroupByToken_1 = require("./Tokens/GroupByToken");
const FieldsToFetchToken_1 = require("./Tokens/FieldsToFetchToken");
const FromToken_1 = require("./Tokens/FromToken");
const DistinctToken_1 = require("./Tokens/DistinctToken");
const QueryStatistics_1 = require("./QueryStatistics");
const Exceptions_1 = require("../../Exceptions");
const IndexQuery_1 = require("../Queries/IndexQuery");
const GroupBy_1 = require("../Queries/GroupBy");
const GroupByKeyToken_1 = require("../Session/Tokens/GroupByKeyToken");
const GroupBySumToken_1 = require("../Session/Tokens/GroupBySumToken");
const TrueToken_1 = require("../Session/Tokens/TrueToken");
const WhereToken_1 = require("../Session/Tokens/WhereToken");
const QueryFieldUtil_1 = require("../Queries/QueryFieldUtil");
const CloseSubclauseToken_1 = require("./Tokens/CloseSubclauseToken");
const OpenSubclauseToken_1 = require("./Tokens/OpenSubclauseToken");
const NegateToken_1 = require("./Tokens/NegateToken");
const WhereParams_1 = require("./WhereParams");
const TypeUtil_1 = require("../../Utility/TypeUtil");
const DateUtil_1 = require("../../Utility/DateUtil");
const MethodCall_1 = require("./MethodCall");
const QueryOperatorToken_1 = require("./Tokens/QueryOperatorToken");
const OrderByToken_1 = require("./Tokens/OrderByToken");
const events_1 = require("events");
const StringBuilder = require("string-builder");
const StringUtil_1 = require("../../Utility/StringUtil");
const IntersectMarkerToken_1 = require("./Tokens/IntersectMarkerToken");
const DocumentConventions_1 = require("../Conventions/DocumentConventions");
const Constants_1 = require("../../Constants");
const DocumentQueryHelper_1 = require("./DocumentQueryHelper");
const ShapeToken_1 = require("./Tokens/ShapeToken");
const SessionEvents_1 = require("./SessionEvents");
const CmpXchng_1 = require("./CmpXchng");
class AbstractDocumentQuery extends events_1.EventEmitter {
    constructor(clazz, session, indexName, collectionName, isGroupBy, declareToken, loadTokens, fromAlias = null) {
        super();
        this._aliasToGroupByFieldName = {};
        this._defaultOperator = "AND";
        this._rootTypes = new Set();
        this._queryParameters = {};
        this._selectTokens = [];
        this._whereTokens = [];
        this._groupByTokens = [];
        this._orderByTokens = [];
        this._includes = new Set();
        this._statsCallback = TypeUtil_1.TypeUtil.NOOP;
        this._queryStats = new QueryStatistics_1.QueryStatistics();
        this._clazz = clazz;
        this._rootTypes.add(clazz);
        this._isGroupBy = isGroupBy;
        this._indexName = indexName;
        this._collectionName = collectionName;
        this._fromToken = FromToken_1.FromToken.create(indexName, collectionName, fromAlias);
        this._declareToken = declareToken;
        this._loadTokens = loadTokens;
        this._theSession = session;
        this.on("afterQueryExecuted", (result) => {
            this._updateStatsAndHighlightings(result);
        });
        this._conventions = !session ?
            new DocumentConventions_1.DocumentConventions() :
            session.conventions;
    }
    get indexName() {
        return this._indexName;
    }
    get collectionName() {
        return this._collectionName;
    }
    get isDistinct() {
        return this._selectTokens
            && this._selectTokens.length
            && this._selectTokens[0] instanceof DistinctToken_1.DistinctToken;
    }
    get conventions() {
        return this._conventions;
    }
    get session() {
        return this._theSession;
    }
    isDynamicMapReduce() {
        return this._groupByTokens && !!this._groupByTokens.length;
    }
    static _getDefaultTimeout() {
        return 25 * 1000;
    }
    _getCurrentWhereTokens() {
        if (!this._isInMoreLikeThis) {
            return this._whereTokens;
        }
        if (!this._whereTokens || !this._whereTokens.length) {
            Exceptions_1.throwError("InvalidOperationException", "Cannot get MoreLikeThisToken because there are no where token specified.");
        }
        Exceptions_1.throwError("NotImplementedException", "More like this");
    }
    _ensureValidFieldName(fieldName, isNestedPath) {
        if (!this._theSession
            || !this._theSession.conventions
            || isNestedPath
            || this._isGroupBy) {
            return QueryFieldUtil_1.QueryFieldUtil.escapeIfNecessary(fieldName);
        }
        for (const rootType of this._rootTypes) {
            const identityProperty = this._theSession.conventions.getIdentityProperty(rootType);
            if (identityProperty && identityProperty === fieldName) {
                return Constants_1.CONSTANTS.Documents.Indexing.Fields.DOCUMENT_ID_FIELD_NAME;
            }
        }
        return QueryFieldUtil_1.QueryFieldUtil.escapeIfNecessary(fieldName);
    }
    _appendOperatorIfNeeded(tokens) {
        this._assertNoRawQuery();
        if (!tokens || !tokens.length) {
            return;
        }
        const lastToken = tokens[tokens.length - 1];
        if (!(lastToken instanceof WhereToken_1.WhereToken) && !(lastToken instanceof CloseSubclauseToken_1.CloseSubclauseToken)) {
            return;
        }
        let lastWhere = null;
        for (let i = tokens.length - 1; i >= 0; i--) {
            if (tokens[i] instanceof WhereToken_1.WhereToken) {
                lastWhere = tokens[i];
                break;
            }
        }
        let token = this._defaultOperator === "AND"
            ? QueryOperatorToken_1.QueryOperatorToken.AND
            : QueryOperatorToken_1.QueryOperatorToken.OR;
        if (lastWhere
            && lastWhere.options.searchOperator) {
            token = QueryOperatorToken_1.QueryOperatorToken.OR;
        }
        tokens.push(token);
    }
    _transformCollection(fieldName, values) {
        const result = [];
        for (const value of values) {
            if (Array.isArray(value)) {
                result.push(...this._transformCollection(fieldName, value));
            }
            else {
                const nestedWhereParams = new WhereParams_1.WhereParams();
                nestedWhereParams.allowWildcards = true;
                nestedWhereParams.fieldName = fieldName;
                nestedWhereParams.value = value;
                result.push(this._transformValue(nestedWhereParams));
            }
        }
        return result;
    }
    _negateIfNeeded(tokens, fieldName) {
        if (!this._negate) {
            return;
        }
        this._negate = false;
        if (!tokens || !tokens.length || tokens[tokens.length - 1] instanceof OpenSubclauseToken_1.OpenSubclauseToken) {
            if (fieldName) {
                this._whereExists(fieldName);
            }
            else {
                this._whereTrue();
            }
            this._andAlso();
        }
        tokens.push(NegateToken_1.NegateToken.INSTANCE);
    }
    _usingDefaultOperator(operator) {
        if (!this._whereTokens || !this._whereTokens.length) {
            Exceptions_1.throwError("InvalidOperationException", "Default operator can only be set before any where clause is added.");
        }
        this._defaultOperator = operator;
    }
    _waitForNonStaleResults(waitTimeout) {
        this._theWaitForNonStaleResults = true;
        this._timeout = waitTimeout || AbstractDocumentQuery._getDefaultTimeout();
    }
    _initializeQueryOperation() {
        const indexQuery = this.getIndexQuery();
        return new QueryOperation_1.QueryOperation(this._theSession, this._indexName, indexQuery, this._fieldsToFetchToken, this._disableEntitiesTracking, false, false);
    }
    _transformValue(whereParams, forRange = false) {
        if (TypeUtil_1.TypeUtil.isNullOrUndefined(whereParams.value)) {
            return null;
        }
        if ("" === whereParams.value) {
            return "";
        }
        const value = whereParams.value;
        if (TypeUtil_1.TypeUtil.isDate(value)) {
            return DateUtil_1.DateUtil.stringify(value);
        }
        if (TypeUtil_1.TypeUtil.isString(value)) {
            return value;
        }
        if (TypeUtil_1.TypeUtil.isNumber(value)) {
            return value;
        }
        if (value === false || value === true) {
            return value;
        }
        return value;
    }
    _addQueryParameter(value) {
        const parameterName = "p" + Object.keys(this._queryParameters).length;
        this._queryParameters[parameterName] = value;
        return parameterName;
    }
    _updateFieldsToFetchToken(fieldsToFetch) {
        this._fieldsToFetchToken = fieldsToFetch;
        if (!this._selectTokens && !this._selectTokens.length) {
            this._selectTokens.push(fieldsToFetch);
        }
        else {
            const fetchToken = [...this._selectTokens]
                .filter(x => x instanceof FieldsToFetchToken_1.FieldsToFetchToken)[0];
            if (fetchToken) {
                const idx = this._selectTokens.indexOf(fetchToken);
                this._selectTokens[idx] = fieldsToFetch;
            }
            else {
                this._selectTokens.push(fieldsToFetch);
            }
        }
    }
    getIndexQuery() {
        const query = this.toString();
        const indexQuery = this._generateIndexQuery(query);
        this.emit("beforeQueryExecuted", indexQuery);
        return indexQuery;
    }
    getProjectionFields() {
        return this._fieldsToFetchToken &&
            this._fieldsToFetchToken.projections
            ? [...this._fieldsToFetchToken.projections]
            : [];
    }
    _randomOrdering(seed) {
        this._assertNoRawQuery();
        if (!seed) {
            this._orderByTokens.push(OrderByToken_1.OrderByToken.random);
            return;
        }
        this._orderByTokens.push(OrderByToken_1.OrderByToken.createRandom(seed));
    }
    addGroupByAlias(fieldName, projectedName) {
        this._aliasToGroupByFieldName[projectedName] = fieldName;
    }
    _assertNoRawQuery() {
        if (this._queryRaw) {
            Exceptions_1.throwError("InvalidOperationException", "RawQuery was called, cannot modify this query by calling on "
                + "operations that would modify the query (such as Where, Select, OrderBy, GroupBy, etc)");
        }
    }
    addParameter(name, value) {
        name = name.replace(/^\$/, "");
        if (Object.keys(this._queryParameters).indexOf(name) !== -1) {
            Exceptions_1.throwError("InvalidOperationException", "The parameter " + name + " was already added");
        }
        this._queryParameters[name] = value;
    }
    _groupBy(fieldOrFieldName, ...fieldsOrFieldNames) {
        if (typeof (fieldOrFieldName) === "string") {
            const mapping = fieldsOrFieldNames.map(x => GroupBy_1.GroupBy.field(x));
            this._groupBy(GroupBy_1.GroupBy.field(fieldOrFieldName), ...mapping);
            return;
        }
        if (!this._fromToken.isDynamic) {
            Exceptions_1.throwError("InvalidOperationException", "groupBy only works with dynamic queries");
        }
        this._assertNoRawQuery();
        this._isGroupBy = true;
        const fieldName = this._ensureValidFieldName(fieldOrFieldName.field, false);
        this._groupByTokens.push(GroupByToken_1.GroupByToken.create(fieldName, fieldOrFieldName.method));
        if (!fieldsOrFieldNames || !fieldsOrFieldNames.length) {
            return;
        }
        for (const item of fieldsOrFieldNames) {
            fieldOrFieldName = this._ensureValidFieldName(item.field, false);
            this._groupByTokens.push(GroupByToken_1.GroupByToken.create(fieldOrFieldName, item.method));
        }
    }
    _groupByKey(fieldName, projectedName = null) {
        this._assertNoRawQuery();
        this._isGroupBy = true;
        if (projectedName && this._aliasToGroupByFieldName[projectedName]) {
            const aliasedFieldName = this._aliasToGroupByFieldName[projectedName];
            if (!fieldName || fieldName.toLocaleLowerCase() === (projectedName || "").toLocaleLowerCase()) {
                fieldName = aliasedFieldName;
            }
        }
        else if (fieldName
            && Object.keys(this._aliasToGroupByFieldName)
                .reduce((result, next) => result || next === fieldName, false)) {
            const aliasedFieldName = this._aliasToGroupByFieldName[fieldName];
            fieldName = aliasedFieldName;
        }
        this._selectTokens.push(GroupByKeyToken_1.GroupByKeyToken.create(fieldName, projectedName));
    }
    _groupBySum(fieldName, projectedName = null) {
        this._assertNoRawQuery();
        this._isGroupBy = true;
        fieldName = this._ensureValidFieldName(fieldName, false);
        this._selectTokens.push(GroupBySumToken_1.GroupBySumToken.create(fieldName, projectedName));
    }
    _groupByCount(projectedName = null) {
        this._assertNoRawQuery();
        this._isGroupBy = true;
        this._selectTokens.push(GroupByCountToken_1.GroupByCountToken.create(projectedName));
    }
    _whereTrue() {
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, null);
        tokens.push(TrueToken_1.TrueToken.INSTANCE);
    }
    _include(path) {
        this._includes.add(path);
    }
    _take(count) {
        this._pageSize = count;
    }
    _skip(count) {
        this._start = count;
    }
    _whereLucene(fieldName, whereClause) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const whereToken = WhereToken_1.WhereToken.create("Lucene", fieldName, this._addQueryParameter(whereClause));
        tokens.push(whereToken);
    }
    _openSubclause() {
        this._currentClauseDepth++;
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, null);
        tokens.push(OpenSubclauseToken_1.OpenSubclauseToken.INSTANCE);
    }
    _closeSubclause() {
        this._currentClauseDepth--;
        const tokens = this._getCurrentWhereTokens();
        tokens.push(CloseSubclauseToken_1.CloseSubclauseToken.INSTANCE);
    }
    _whereEquals(fieldNameOrWhereParams, value, exact = false) {
        if (!TypeUtil_1.TypeUtil.isObject(fieldNameOrWhereParams)) {
            const params = new WhereParams_1.WhereParams();
            params.fieldName = fieldNameOrWhereParams;
            params.value = value;
            params.exact = exact;
            this._whereEquals(params);
            return;
        }
        const whereParams = fieldNameOrWhereParams;
        if (this._negate) {
            this._negate = false;
            this._whereNotEquals(whereParams);
            return;
        }
        whereParams.fieldName = this._ensureValidFieldName(whereParams.fieldName, whereParams.nestedPath);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        if (this._ifValueIsMethod("Equals", whereParams, tokens)) {
            return;
        }
        const transformToEqualValue = this._transformValue(whereParams);
        const addQueryParameter = this._addQueryParameter(transformToEqualValue);
        const whereToken = WhereToken_1.WhereToken.create("Equals", whereParams.fieldName, addQueryParameter, new WhereToken_1.WhereOptions({
            exact: whereParams.exact
        }));
        tokens.push(whereToken);
    }
    _ifValueIsMethod(op, whereParams, tokens) {
        if (whereParams.value instanceof MethodCall_1.MethodCall) {
            const mc = whereParams.value;
            const args = mc.args.map(x => null);
            for (let i = 0; i < mc.args.length; i++) {
                args[i] = this._addQueryParameter(mc.args[i]);
            }
            let token;
            const type = mc.constructor.name;
            if (CmpXchng_1.CmpXchg.name === type) {
                token = WhereToken_1.WhereToken.create(op, whereParams.fieldName, null, new WhereToken_1.WhereOptions({
                    methodType: "CmpXchg",
                    parameters: args,
                    property: mc.accessPath,
                    exact: whereParams.exact
                }));
            }
            else {
                Exceptions_1.throwError("InvalidArgumentException", `Unknown method ${type}.`);
            }
            tokens.push(token);
            return true;
        }
        return false;
    }
    _whereNotEquals(fieldNameOrWhereParams, value, exact = false) {
        let whereParams;
        if (TypeUtil_1.TypeUtil.isString(fieldNameOrWhereParams)) {
            whereParams = new WhereParams_1.WhereParams();
            whereParams.fieldName = fieldNameOrWhereParams;
            whereParams.value = value;
            whereParams.exact = exact;
            return this._whereNotEquals(whereParams);
        }
        whereParams = fieldNameOrWhereParams;
        if (this._negate) {
            this._negate = false;
            this._whereEquals(whereParams);
            return;
        }
        const transformToEqualValue = this._transformValue(whereParams);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        whereParams.fieldName = this._ensureValidFieldName(whereParams.fieldName, whereParams.nestedPath);
        if (this._ifValueIsMethod("NotEquals", whereParams, tokens)) {
            return;
        }
        const whereToken = WhereToken_1.WhereToken.create("NotEquals", whereParams.fieldName, this._addQueryParameter(transformToEqualValue), new WhereToken_1.WhereOptions(whereParams.exact));
        tokens.push(whereToken);
    }
    negateNext() {
        this._negate = !this._negate;
    }
    _whereIn(fieldName, values, exact = false) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const whereToken = WhereToken_1.WhereToken.create("In", fieldName, this._addQueryParameter(this._transformCollection(fieldName, AbstractDocumentQuery._unpackCollection(values))));
        tokens.push(whereToken);
    }
    _whereStartsWith(fieldName, value) {
        const whereParams = new WhereParams_1.WhereParams();
        whereParams.fieldName = fieldName;
        whereParams.value = value;
        whereParams.allowWildcards = true;
        const transformToEqualValue = this._transformValue(whereParams);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        whereParams.fieldName = this._ensureValidFieldName(whereParams.fieldName, whereParams.nestedPath);
        this._negateIfNeeded(tokens, whereParams.fieldName);
        const whereToken = WhereToken_1.WhereToken.create("StartsWith", whereParams.fieldName, this._addQueryParameter(transformToEqualValue));
        tokens.push(whereToken);
    }
    _whereEndsWith(fieldName, value) {
        const whereParams = new WhereParams_1.WhereParams();
        whereParams.fieldName = fieldName;
        whereParams.value = value;
        whereParams.allowWildcards = true;
        const transformToEqualValue = this._transformValue(whereParams);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        whereParams.fieldName = this._ensureValidFieldName(whereParams.fieldName, whereParams.nestedPath);
        this._negateIfNeeded(tokens, whereParams.fieldName);
        const whereToken = WhereToken_1.WhereToken.create("EndsWith", whereParams.fieldName, this._addQueryParameter(transformToEqualValue));
        tokens.push(whereToken);
    }
    _whereBetween(fieldName, start, end, exact = false) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const startParams = new WhereParams_1.WhereParams();
        startParams.value = start;
        startParams.fieldName = fieldName;
        const endParams = new WhereParams_1.WhereParams();
        endParams.value = end;
        endParams.fieldName = fieldName;
        const fromParameterName = this._addQueryParameter(!start ? "*" : this._transformValue(startParams, true));
        const toParameterName = this._addQueryParameter(!start ? "NULL" : this._transformValue(endParams, true));
        const whereToken = WhereToken_1.WhereToken.create("Between", fieldName, null, new WhereToken_1.WhereOptions({
            exact,
            from: fromParameterName,
            to: toParameterName
        }));
        tokens.push(whereToken);
    }
    _whereGreaterThan(fieldName, value, exact = false) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const whereParams = new WhereParams_1.WhereParams();
        whereParams.value = value;
        whereParams.fieldName = fieldName;
        const parameter = this._addQueryParameter(!value ? "*" : this._transformValue(whereParams, true));
        const whereToken = WhereToken_1.WhereToken.create("GreaterThan", fieldName, parameter, new WhereToken_1.WhereOptions({ exact }));
        tokens.push(whereToken);
    }
    _whereGreaterThanOrEqual(fieldName, value, exact = false) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const whereParams = new WhereParams_1.WhereParams();
        whereParams.value = value;
        whereParams.fieldName = fieldName;
        const parameter = this._addQueryParameter(!value ? "*" : this._transformValue(whereParams, true));
        const whereToken = WhereToken_1.WhereToken.create("GreaterThanOrEqual", fieldName, parameter, new WhereToken_1.WhereOptions({ exact }));
        tokens.push(whereToken);
    }
    _whereLessThan(fieldName, value, exact = false) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const whereParams = new WhereParams_1.WhereParams();
        whereParams.value = value;
        whereParams.fieldName = fieldName;
        const parameter = this._addQueryParameter(!value ? "NULL" : this._transformValue(whereParams, true));
        const whereToken = WhereToken_1.WhereToken.create("LessThan", fieldName, parameter, new WhereToken_1.WhereOptions({ exact }));
        tokens.push(whereToken);
    }
    _whereLessThanOrEqual(fieldName, value, exact = false) {
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const whereParams = new WhereParams_1.WhereParams();
        whereParams.value = value;
        whereParams.fieldName = fieldName;
        const parameter = this._addQueryParameter(!value ? "NULL" : this._transformValue(whereParams, true));
        const whereToken = WhereToken_1.WhereToken.create("LessThanOrEqual", fieldName, parameter, new WhereToken_1.WhereOptions({ exact }));
        tokens.push(whereToken);
    }
    _whereRegex(fieldName, pattern) {
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const whereParams = new WhereParams_1.WhereParams();
        whereParams.value = pattern;
        whereParams.fieldName = fieldName;
        const parameter = this._addQueryParameter(this._transformValue(whereParams));
        const whereToken = WhereToken_1.WhereToken.create("Regex", fieldName, parameter);
        tokens.push(whereToken);
    }
    _andAlso() {
        const tokens = this._getCurrentWhereTokens();
        if (!tokens && !tokens.length) {
            return;
        }
        if (tokens[tokens.length - 1] instanceof QueryOperatorToken_1.QueryOperatorToken) {
            Exceptions_1.throwError("InvalidOperationException", "Cannot add AND, previous token was already an operator token.");
        }
        tokens.push(QueryOperatorToken_1.QueryOperatorToken.AND);
    }
    _orElse() {
        const tokens = this._getCurrentWhereTokens();
        if (!tokens && !tokens.length) {
            return;
        }
        if (tokens[tokens.length - 1] instanceof QueryOperatorToken_1.QueryOperatorToken) {
            Exceptions_1.throwError("InvalidOperationException", "Cannot add OR, previous token was already an operator token.");
        }
        tokens.push(QueryOperatorToken_1.QueryOperatorToken.OR);
    }
    _boost(boost) {
        if (boost === 1.0) {
            return;
        }
        const tokens = this._getCurrentWhereTokens();
        if (!tokens && !tokens.length) {
            Exceptions_1.throwError("InvalidOperationException", "Missing where clause.");
        }
        const whereToken = tokens[tokens.length - 1];
        if (!(whereToken instanceof WhereToken_1.WhereToken)) {
            Exceptions_1.throwError("InvalidOperationException", "Missing where clause.");
        }
        if (boost <= 0.0) {
            Exceptions_1.throwError("InvalidArgumentException", "Boost factor must be a positive number.");
        }
        whereToken.options.boost = boost;
    }
    _fuzzy(fuzzy) {
        const tokens = this._getCurrentWhereTokens();
        if (!tokens && !tokens.length) {
            Exceptions_1.throwError("InvalidOperationException", "Missing where clause.");
        }
        const whereToken = tokens[tokens.length - 1];
        if (!(whereToken instanceof WhereToken_1.WhereToken)) {
            Exceptions_1.throwError("InvalidOperationException", "Missing where clause.");
        }
        if (fuzzy < 0.0 || fuzzy > 1.0) {
            Exceptions_1.throwError("InvalidArgumentException", "Fuzzy distance must be between 0.0 and 1.0.");
        }
        whereToken.options.fuzzy = fuzzy;
    }
    _proximity(proximity) {
        const tokens = this._getCurrentWhereTokens();
        if (!tokens && !tokens.length) {
            Exceptions_1.throwError("InvalidOperationException", "Missing where clause.");
        }
        const whereToken = tokens[tokens.length - 1];
        if (!(whereToken instanceof WhereToken_1.WhereToken)) {
            Exceptions_1.throwError("InvalidOperationException", "Missing where clause.");
        }
        if (proximity < 1) {
            Exceptions_1.throwError("InvalidArgumentException", "Proximity distance must be a positive number.");
        }
        whereToken.options.proximity = proximity;
    }
    _orderBy(field, ordering = "String") {
        this._assertNoRawQuery();
        const f = this._ensureValidFieldName(field, false);
        this._orderByTokens.push(OrderByToken_1.OrderByToken.createAscending(f, ordering));
    }
    _orderByDescending(field, ordering = "String") {
        this._assertNoRawQuery();
        const f = this._ensureValidFieldName(field, false);
        this._orderByTokens.push(OrderByToken_1.OrderByToken.createDescending(f, ordering));
    }
    _orderByScore() {
        this._assertNoRawQuery();
        this._orderByTokens.push(OrderByToken_1.OrderByToken.scoreAscending);
    }
    _orderByScoreDescending() {
        this._assertNoRawQuery();
        this._orderByTokens.push(OrderByToken_1.OrderByToken.scoreDescending);
    }
    _statistics(statsCallback) {
        statsCallback(this._queryStats);
    }
    _generateIndexQuery(query) {
        const indexQuery = new IndexQuery_1.IndexQuery();
        indexQuery.query = query;
        indexQuery.start = this._start;
        indexQuery.waitForNonStaleResults = this._theWaitForNonStaleResults;
        indexQuery.waitForNonStaleResultsTimeout = this._timeout;
        indexQuery.queryParameters = this._queryParameters;
        indexQuery.disableCaching = this._disableCaching;
        if (this._pageSize) {
            indexQuery.pageSize = this._pageSize;
        }
        return indexQuery;
    }
    _search(fieldName, searchTerms, operator = "OR") {
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        fieldName = this._ensureValidFieldName(fieldName, false);
        this._negateIfNeeded(tokens, fieldName);
        const whereToken = WhereToken_1.WhereToken.create("Search", fieldName, this._addQueryParameter(searchTerms), new WhereToken_1.WhereOptions({ search: operator }));
        tokens.push(whereToken);
    }
    toString() {
        if (this._queryRaw) {
            return this._queryRaw;
        }
        if (this._currentClauseDepth) {
            Exceptions_1.throwError("InvalidOperationException", "A clause was not closed correctly within this query, current clause depth = "
                + this._currentClauseDepth);
        }
        const queryText = new StringBuilder();
        this._buildDeclare(queryText);
        this._buildFrom(queryText);
        this._buildGroupBy(queryText);
        this._buildWhere(queryText);
        this._buildOrderBy(queryText);
        this._buildLoad(queryText);
        this._buildSelect(queryText);
        this._buildInclude(queryText);
        return queryText.toString();
    }
    _buildInclude(queryText) {
        if (!this._includes || !this._includes.size) {
            return;
        }
        queryText.append(" include ");
        let first = true;
        for (const include of this._includes) {
            if (!first) {
                queryText.append(",");
            }
            first = false;
            let requiredQuotes = false;
            for (let i = 0; i < include.length; i++) {
                const ch = include[i];
                if (!StringUtil_1.StringUtil.isLetterOrDigit(ch) && ch !== "_" && ch !== ".") {
                    requiredQuotes = true;
                    break;
                }
            }
            if (requiredQuotes) {
                queryText.append("'").append(include.replace(/'/g, "\'")).append("'");
            }
            else {
                queryText.append(include);
            }
        }
    }
    _intersect() {
        const tokens = this._getCurrentWhereTokens();
        if (tokens.length > 0) {
            const last = tokens[tokens.length - 1];
            if (last instanceof WhereToken_1.WhereToken || last instanceof CloseSubclauseToken_1.CloseSubclauseToken) {
                this._isIntersect = true;
                tokens.push(IntersectMarkerToken_1.IntersectMarkerToken.INSTANCE);
                return;
            }
        }
        Exceptions_1.throwError("InvalidOperationException", "Cannot add INTERSECT at this point.");
    }
    _whereExists(fieldName) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        tokens.push(WhereToken_1.WhereToken.create("Exists", fieldName, null));
    }
    _containsAny(fieldName, values) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const array = this._transformCollection(fieldName, AbstractDocumentQuery._unpackCollection(values));
        const whereToken = WhereToken_1.WhereToken.create("In", fieldName, this._addQueryParameter(array), new WhereToken_1.WhereOptions({ exact: false }));
        tokens.push(whereToken);
    }
    _containsAll(fieldName, values) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const array = this._transformCollection(fieldName, AbstractDocumentQuery._unpackCollection(values));
        if (!array.length) {
            tokens.push(TrueToken_1.TrueToken.INSTANCE);
            return;
        }
        const whereToken = WhereToken_1.WhereToken.create("AllIn", fieldName, this._addQueryParameter(array));
        tokens.push(whereToken);
    }
    addRootType(clazz) {
        this._rootTypes.add(clazz);
    }
    _distinct() {
        if (this.isDistinct) {
            Exceptions_1.throwError("InvalidOperationException", "This is already a distinct query.");
        }
        if (!this._selectTokens.length) {
            this._selectTokens.push(DistinctToken_1.DistinctToken.INSTANCE);
        }
        else {
            this._selectTokens.unshift(DistinctToken_1.DistinctToken.INSTANCE);
        }
    }
    _updateStatsAndHighlightings(queryResult) {
        this._queryStats.updateQueryStats(queryResult);
    }
    _buildSelect(writer) {
        if (!this._selectTokens || !this._selectTokens.length) {
            return;
        }
        writer.append(" select ");
        if (this._selectTokens.length === 1 && this._selectTokens[0] instanceof DistinctToken_1.DistinctToken) {
            this._selectTokens[0].writeTo(writer);
            writer.append(" *");
            return;
        }
        for (let i = 0; i < this._selectTokens.length; i++) {
            const token = this._selectTokens[i];
            if (i > 0 && !(this._selectTokens[i - 1] instanceof DistinctToken_1.DistinctToken)) {
                writer.append(",");
            }
            DocumentQueryHelper_1.DocumentQueryHelper.addSpaceIfNeeded(i > 0 ? this._selectTokens[i - 1] : null, token, writer);
            token.writeTo(writer);
        }
    }
    _buildFrom(writer) {
        this._fromToken.writeTo(writer);
    }
    _buildDeclare(writer) {
        if (this._declareToken) {
            this._declareToken.writeTo(writer);
        }
    }
    _buildLoad(writer) {
        if (!this._loadTokens || !this._loadTokens.length) {
            return;
        }
        writer.append(" load ");
        for (let i = 0; i < this._loadTokens.length; i++) {
            if (i !== 0) {
                writer.append(", ");
            }
            this._loadTokens[i].writeTo(writer);
        }
    }
    _buildWhere(writer) {
        if (!this._whereTokens || !this._whereTokens.length) {
            return;
        }
        writer
            .append(" where ");
        if (this._isIntersect) {
            writer
                .append("intersect(");
        }
        for (let i = 0; i < this._whereTokens.length; i++) {
            DocumentQueryHelper_1.DocumentQueryHelper.addSpaceIfNeeded(i > 0 ? this._whereTokens[i - 1] : null, this._whereTokens[i], writer);
            this._whereTokens[i].writeTo(writer);
        }
        if (this._isIntersect) {
            writer.append(") ");
        }
    }
    _buildGroupBy(writer) {
        if (!this._groupByTokens || !this._groupByTokens.length) {
            return;
        }
        writer
            .append(" group by ");
        let isFirst = true;
        for (const token of this._groupByTokens) {
            if (!isFirst) {
                writer.append(", ");
            }
            token.writeTo(writer);
            isFirst = false;
        }
    }
    _buildOrderBy(writer) {
        if (!this._orderByTokens || !this._orderByTokens.length) {
            return;
        }
        writer
            .append(" order by ");
        let isFirst = true;
        for (const token of this._orderByTokens) {
            if (!isFirst) {
                writer.append(", ");
            }
            token.writeTo(writer);
            isFirst = false;
        }
    }
    static _unpackCollection(items) {
        const results = [];
        for (const item of items) {
            if (Array.isArray(item)) {
                results.push(...AbstractDocumentQuery._unpackCollection(item));
            }
            else {
                results.push(item);
            }
        }
        return results;
    }
    queryOperation() {
        return this._queryOperation;
    }
    _noTracking() {
        this._disableEntitiesTracking = true;
    }
    _noCaching() {
        this._disableCaching = true;
    }
    _withinRadiusOf(fieldName, radius, latitude, longitude, radiusUnits, distErrorPercent) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const whereToken = WhereToken_1.WhereToken.create("SpatialWithin", fieldName, null, new WhereToken_1.WhereOptions({
            shape: ShapeToken_1.ShapeToken.circle(this._addQueryParameter(radius), this._addQueryParameter(latitude), this._addQueryParameter(longitude), radiusUnits),
            distance: distErrorPercent
        }));
        tokens.push(whereToken);
    }
    _spatialByShapeWkt(fieldName, shapeWkt, relation, distErrorPercent) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const wktToken = ShapeToken_1.ShapeToken.wkt(this._addQueryParameter(shapeWkt));
        let whereOperator;
        switch (relation) {
            case "Within":
                whereOperator = "SpatialWithin";
                break;
            case "Contains":
                whereOperator = "SpatialContains";
                break;
            case "Disjoint":
                whereOperator = "SpatialDisjoint";
                break;
            case "Intersects":
                whereOperator = "SpatialIntersects";
                break;
            default:
                Exceptions_1.throwError("InvalidArgumentException", `relation: ${relation}.`);
        }
        tokens.push(WhereToken_1.WhereToken.create(whereOperator, fieldName, null, new WhereToken_1.WhereOptions({
            shape: wktToken,
            distance: distErrorPercent
        })));
    }
    _spatial(fieldNameOrDynamicSpatialField, criteria) {
        let tokens;
        if (typeof (fieldNameOrDynamicSpatialField) === "string") {
            const fieldName = this._ensureValidFieldName(fieldNameOrDynamicSpatialField, false);
            tokens = this._getCurrentWhereTokens();
            this._appendOperatorIfNeeded(tokens);
            this._negateIfNeeded(tokens, fieldName);
            tokens.push(criteria.toQueryToken(fieldName, (o) => this._addQueryParameter(o)));
            return;
        }
        const dynamicField = fieldNameOrDynamicSpatialField;
        tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, null);
        tokens.push(criteria.toQueryToken(dynamicField.toField((fName, isNestedPath) => this._ensureValidFieldName(fName, isNestedPath)), (o) => this._addQueryParameter(o)));
    }
    _orderByDistance(fieldNameOrField, shapeWktOrLatitude, longitude) {
        if (TypeUtil_1.TypeUtil.isString(fieldNameOrField)) {
            if (TypeUtil_1.TypeUtil.isString(shapeWktOrLatitude)) {
                this._orderByTokens.push(OrderByToken_1.OrderByToken.createDistanceAscending(fieldNameOrField, this._addQueryParameter(shapeWktOrLatitude)));
            }
            else {
                this._orderByTokens.push(OrderByToken_1.OrderByToken.createDistanceAscending(fieldNameOrField, this._addQueryParameter(shapeWktOrLatitude), this._addQueryParameter(longitude)));
            }
            return;
        }
        const field = fieldNameOrField;
        if (!fieldNameOrField) {
            Exceptions_1.throwError("InvalidArgumentException", "Field cannot be null.");
        }
        if (TypeUtil_1.TypeUtil.isString(shapeWktOrLatitude)) {
            this._orderByDistance("'" + field.toField((f, isNestedPath) => this._ensureValidFieldName(f, isNestedPath)) + "'", shapeWktOrLatitude);
        }
        else {
            this._orderByDistance("'" + field.toField((f, isNestedPath) => this._ensureValidFieldName(f, isNestedPath)) + "'", shapeWktOrLatitude, longitude);
        }
    }
    _orderByDistanceDescending(fieldNameOrField, shapeWktOrLatitude, longitude) {
        if (TypeUtil_1.TypeUtil.isString(fieldNameOrField)) {
            if (TypeUtil_1.TypeUtil.isString(shapeWktOrLatitude)) {
                this._orderByTokens.push(OrderByToken_1.OrderByToken.createDistanceDescending(fieldNameOrField, this._addQueryParameter(shapeWktOrLatitude)));
            }
            else {
                this._orderByTokens.push(OrderByToken_1.OrderByToken.createDistanceDescending(fieldNameOrField, this._addQueryParameter(shapeWktOrLatitude), this._addQueryParameter(longitude)));
            }
            return;
        }
        const field = fieldNameOrField;
        if (!fieldNameOrField) {
            Exceptions_1.throwError("InvalidArgumentException", "Field cannot be null.");
        }
        if (TypeUtil_1.TypeUtil.isString(shapeWktOrLatitude)) {
            this._orderByDistanceDescending("'" + field.toField((f, isNestedPath) => this._ensureValidFieldName(f, isNestedPath)) + "'", shapeWktOrLatitude);
        }
        else {
            this._orderByDistanceDescending("'" + field.toField((f, isNestedPath) => this._ensureValidFieldName(f, isNestedPath)) + "'", shapeWktOrLatitude, longitude);
        }
    }
    _initSync() {
        if (this._queryOperation) {
            return Promise.resolve();
        }
        const beforeQueryEventArgs = new SessionEvents_1.SessionBeforeQueryEventArgs(this._theSession);
        this._theSession.emit("beforeQuery", beforeQueryEventArgs);
        this._queryOperation = this._initializeQueryOperation();
        return this._executeActualQuery();
    }
    _executeActualQuery() {
        let context;
        let command;
        const result = BluebirdPromise.resolve()
            .then(() => {
            context = this._queryOperation.enterQueryContext();
            command = this._queryOperation.createRequest();
            return this._theSession.requestExecutor.execute(command, this._theSession.sessionInfo);
        })
            .then(() => {
            this._queryOperation.setResult(command.result);
            this.emit("afterQueryExecuted", this._queryOperation.getCurrentQueryResults());
        })
            .finally(() => {
            if (context) {
                context.dispose();
            }
        });
        return Promise.resolve(result);
    }
    iterator() {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve()
                .then(() => this._initSync())
                .then(() => {
                const results = this._queryOperation.complete(this._clazz);
                return results[Symbol.iterator]();
            });
        });
    }
    all(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            callback = callback || TypeUtil_1.TypeUtil.NOOP;
            const result = BluebirdPromise.resolve(this.iterator())
                .then((entries) => [...entries])
                .tap(x => callback(null, x))
                .tapCatch(err => callback(err));
            return Promise.resolve(result);
        });
    }
    getQueryResult() {
        return Promise.resolve()
            .then(() => this._initSync())
            .then(() => this._queryOperation.getCurrentQueryResults().createSnapshot());
    }
    first(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            callback = callback || TypeUtil_1.TypeUtil.NOOP;
            const result = BluebirdPromise.resolve()
                .then(() => this._executeQueryOperation(2))
                .then(entries => entries[0] || null)
                .tap(x => callback(null, x))
                .tapCatch(err => callback(err));
            return Promise.resolve(result);
        });
    }
    single(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            callback = callback || TypeUtil_1.TypeUtil.NOOP;
            const result = BluebirdPromise.resolve()
                .then(() => this._executeQueryOperation(2))
                .then(entries => {
                if (entries.length > 1) {
                    throw Exceptions_1.getError("InvalidOperationException", "Expected single result, got: " + entries.length);
                }
                return entries[0] || null;
            })
                .tap(x => callback(null, x))
                .tapCatch(err => callback(err));
            return Promise.resolve(result);
        });
    }
    count(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            callback = callback || TypeUtil_1.TypeUtil.NOOP;
            this._take(0);
            const result = BluebirdPromise.resolve(this.getQueryResult())
                .then(queryResult => queryResult.totalResults)
                .tap(x => callback(null, x))
                .tapCatch(err => callback(err));
            return Promise.resolve(result);
        });
    }
    _executeQueryOperation(take) {
        if (!this._pageSize || this._pageSize > take) {
            this._take(take);
        }
        return Promise.resolve()
            .then(() => this._initSync())
            .then(() => {
            return this._queryOperation.complete(this._clazz);
        });
    }
}
exports.AbstractDocumentQuery = AbstractDocumentQuery;
