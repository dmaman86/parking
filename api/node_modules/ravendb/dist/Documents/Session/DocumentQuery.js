"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AbstractDocumentQuery_1 = require("./AbstractDocumentQuery");
const Exceptions_1 = require("../../Exceptions");
const Constants_1 = require("../../Constants");
const QueryData_1 = require("../Queries/QueryData");
const GroupByDocumentQuery_1 = require("./GroupByDocumentQuery");
const FieldsToFetchToken_1 = require("./Tokens/FieldsToFetchToken");
const SpatialCriteriaFactory_1 = require("../Queries/Spatial/SpatialCriteriaFactory");
const TypeUtil_1 = require("../../Utility/TypeUtil");
class DocumentQuery extends AbstractDocumentQuery_1.AbstractDocumentQuery {
    constructor(documentType, session, indexName, collectionName, isGroupBy, declareToken, loadTokens, fromAlias) {
        super(documentType, session, indexName, collectionName, isGroupBy, declareToken, loadTokens, fromAlias);
    }
    selectFields(propertiesOrQueryData, projectionType) {
        if (projectionType) {
            this._theSession.conventions.tryRegisterEntityType(projectionType);
        }
        if (TypeUtil_1.TypeUtil.isString(propertiesOrQueryData)) {
            propertiesOrQueryData = [propertiesOrQueryData];
        }
        if (Array.isArray(propertiesOrQueryData)) {
            if (projectionType) {
                return this._selectFieldsByProjectionType(propertiesOrQueryData, projectionType);
            }
            const queryData = new QueryData_1.QueryData(propertiesOrQueryData, propertiesOrQueryData);
            return this.selectFields(queryData, projectionType);
        }
        else {
            return this._createDocumentQueryInternal(projectionType, propertiesOrQueryData);
        }
    }
    _selectFieldsByProjectionType(properties, projectionType) {
        if (!properties || !properties.length) {
            Exceptions_1.throwError("InvalidArgumentException", "Fields cannot be null or empty.");
        }
        try {
            const identityProperty = this.conventions.getIdentityProperty(projectionType);
            const projections = properties;
            const fields = properties.map(x => x === identityProperty
                ? Constants_1.CONSTANTS.Documents.Indexing.Fields.DOCUMENT_ID_FIELD_NAME
                : x);
            return this.selectFields(new QueryData_1.QueryData(fields, projections), projectionType);
        }
        catch (err) {
            Exceptions_1.throwError("RavenException", "Unable to project to type: " + projectionType, err);
        }
    }
    distinct() {
        this._distinct();
        return this;
    }
    orderByScore() {
        this._orderByScore();
        return this;
    }
    orderByScoreDescending() {
        this._orderByScoreDescending();
        return this;
    }
    waitForNonStaleResults(waitTimeout = null) {
        this._waitForNonStaleResults(waitTimeout);
        return this;
    }
    addParameter(name, value) {
        super.addParameter(name, value);
        return this;
    }
    addOrder(fieldName, descending, ordering = "String") {
        if (descending) {
            this.orderByDescending(fieldName, ordering);
        }
        else {
            this.orderBy(fieldName, ordering);
        }
        return this;
    }
    openSubclause() {
        this._openSubclause();
        return this;
    }
    closeSubclause() {
        this._closeSubclause();
        return this;
    }
    search(fieldName, searchTerms, operator) {
        this._search(fieldName, searchTerms, operator);
        return this;
    }
    intersect() {
        this._intersect();
        return this;
    }
    containsAny(fieldName, values) {
        this._containsAny(fieldName, values);
        return this;
    }
    containsAll(fieldName, values) {
        this._containsAll(fieldName, values);
        return this;
    }
    statistics(stats) {
        this._statistics(stats);
        return this;
    }
    usingDefaultOperator(queryOperator) {
        this._usingDefaultOperator(queryOperator);
        return this;
    }
    noTracking() {
        this._noTracking();
        return this;
    }
    noCaching() {
        this._noCaching();
        return this;
    }
    include(path) {
        this._include(path);
        return this;
    }
    not() {
        this.negateNext();
        return this;
    }
    take(count) {
        this._take(count);
        return this;
    }
    skip(count) {
        this._skip(count);
        return this;
    }
    whereLucene(fieldName, whereClause) {
        this._whereLucene(fieldName, whereClause);
        return this;
    }
    whereEquals(...args) {
        this._whereEquals(...args);
        return this;
    }
    whereNotEquals(...args) {
        this._whereNotEquals(...args);
        return this;
    }
    whereIn(...args) {
        this._whereIn(...args);
        return this;
    }
    whereStartsWith(fieldName, value) {
        this._whereStartsWith(fieldName, value);
        return this;
    }
    whereEndsWith(fieldName, value) {
        this._whereEndsWith(fieldName, value);
        return this;
    }
    whereBetween(...args) {
        this._whereBetween(...args);
        return this;
    }
    whereGreaterThan(...args) {
        this._whereGreaterThan(...args);
        return this;
    }
    whereGreaterThanOrEqual(...args) {
        this._whereGreaterThanOrEqual(...args);
        return this;
    }
    whereLessThan(...args) {
        this._whereLessThan(...args);
        return this;
    }
    whereLessThanOrEqual(...args) {
        this._whereLessThanOrEqual(...args);
        return this;
    }
    whereExists(fieldName) {
        this._whereExists(fieldName);
        return this;
    }
    whereRegex(fieldName, pattern) {
        this._whereRegex(fieldName, pattern);
        return this;
    }
    andAlso() {
        this._andAlso();
        return this;
    }
    orElse() {
        this._orElse();
        return this;
    }
    boost(boost) {
        this._boost(boost);
        return this;
    }
    fuzzy(fuzzy) {
        this._fuzzy(fuzzy);
        return this;
    }
    proximity(proximity) {
        this._proximity(proximity);
        return this;
    }
    randomOrdering(seed) {
        this._randomOrdering(seed);
        return this;
    }
    groupBy(...args) {
        this._groupBy(...args);
        return new GroupByDocumentQuery_1.GroupByDocumentQuery(this);
    }
    ofType(tResultClass) {
        if (tResultClass) {
            this._theSession.conventions.tryRegisterEntityType(tResultClass);
        }
        return this._createDocumentQueryInternal(tResultClass);
    }
    orderBy(...args) {
        this._orderBy(...args);
        return this;
    }
    orderByDescending(...args) {
        this._orderByDescending(...args);
        return this;
    }
    _createDocumentQueryInternal(resultClass, queryData) {
        const newFieldsToFetch = queryData && queryData.fields.length > 0
            ? FieldsToFetchToken_1.FieldsToFetchToken.create(queryData.fields, queryData.projections, queryData.isCustomFunction)
            : null;
        if (newFieldsToFetch) {
            this._updateFieldsToFetchToken(newFieldsToFetch);
        }
        const query = new DocumentQuery(resultClass, this._theSession, this.indexName, this.collectionName, this._isGroupBy, queryData ? queryData.declareToken : null, queryData ? queryData.loadTokens : null, queryData ? queryData.fromAlias : null);
        query._queryRaw = this._queryRaw;
        query._pageSize = this._pageSize;
        query._selectTokens = this._selectTokens;
        query._fieldsToFetchToken = this._fieldsToFetchToken;
        query._whereTokens = this._whereTokens;
        query._orderByTokens = this._orderByTokens;
        query._groupByTokens = this._groupByTokens;
        query._queryParameters = this._queryParameters;
        query._start = this._start;
        query._timeout = this._timeout;
        query._queryStats = this._queryStats;
        query._theWaitForNonStaleResults = this._theWaitForNonStaleResults;
        query._negate = this._negate;
        query._includes = new Set(this._includes);
        query._rootTypes = new Set([this._clazz]);
        for (const listener of query.listeners("beforeQuery")) {
            query.on("beforeQuery", listener);
        }
        for (const listener of query.listeners("afterQuery")) {
            query.on("afterQuery", listener);
        }
        query._disableEntitiesTracking = this._disableEntitiesTracking;
        query._disableCaching = this._disableCaching;
        query._isIntersect = this._isIntersect;
        query._defaultOperator = this._defaultOperator;
        return query;
    }
    spatial(fieldNameOrField, clause) {
        const criteria = clause(SpatialCriteriaFactory_1.SpatialCriteriaFactory.INSTANCE);
        this._spatial(fieldNameOrField, criteria);
        return this;
    }
    withinRadiusOf(fieldName, radius, latitude, longitude, radiusUnits = null, distanceErrorPct = Constants_1.CONSTANTS.Documents.Indexing.Spatial.DEFAULT_DISTANCE_ERROR_PCT) {
        this._withinRadiusOf(fieldName, radius, latitude, longitude, radiusUnits, distanceErrorPct);
        return this;
    }
    relatesToShape(fieldName, shapeWkt, relation, distanceErrorPct = Constants_1.CONSTANTS.Documents.Indexing.Spatial.DEFAULT_DISTANCE_ERROR_PCT) {
        this._spatialByShapeWkt(fieldName, shapeWkt, relation, distanceErrorPct);
        return this;
    }
    orderByDistance(...args) {
        this._orderByDistance(...args);
        return this;
    }
    orderByDistanceDescending(...args) {
        this._orderByDistanceDescending(...args);
        return this;
    }
}
exports.DocumentQuery = DocumentQuery;
