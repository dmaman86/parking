"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const DocumentQuery_1 = require("./DocumentQuery");
const MultiLoaderWithInclude_1 = require("./Loaders/MultiLoaderWithInclude");
const BatchOperation_1 = require("./Operations/BatchOperation");
const BluebirdPromise = require("bluebird");
const TypeUtil_1 = require("../../Utility/TypeUtil");
const Exceptions_1 = require("../../Exceptions");
const LoadOperation_1 = require("./Operations/LoadOperation");
const InMemoryDocumentSessionOperations_1 = require("./InMemoryDocumentSessionOperations");
const GetDocumentsCommand_1 = require("../Commands/GetDocumentsCommand");
const HeadDocumentCommand_1 = require("../Commands/HeadDocumentCommand");
const LoadStartingWithOperation_1 = require("./Operations/LoadStartingWithOperation");
const RawDocumentQuery_1 = require("./RawDocumentQuery");
class DocumentSession extends InMemoryDocumentSessionOperations_1.InMemoryDocumentSessionOperations {
    constructor(dbName, documentStore, id, requestExecutor) {
        super(dbName, documentStore, requestExecutor, id);
    }
    get advanced() {
        return this;
    }
    _generateId(entity) {
        return this.conventions.generateDocumentId(this.databaseName, entity);
    }
    load(idOrIds, optionsOrCallback, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const isLoadingSingle = !Array.isArray(idOrIds);
            const ids = !isLoadingSingle ? idOrIds : [idOrIds];
            let options;
            if (TypeUtil_1.TypeUtil.isDocumentType(optionsOrCallback)) {
                options = { documentType: optionsOrCallback };
            }
            else if (TypeUtil_1.TypeUtil.isFunction(optionsOrCallback)) {
                callback = optionsOrCallback || TypeUtil_1.TypeUtil.NOOP;
            }
            else if (TypeUtil_1.TypeUtil.isObject(optionsOrCallback)) {
                options = optionsOrCallback;
            }
            callback = callback || TypeUtil_1.TypeUtil.NOOP;
            options = options || {};
            this.conventions.tryRegisterEntityType(options.documentType);
            const objType = this.conventions.findEntityType(options.documentType);
            const loadOperation = new LoadOperation_1.LoadOperation(this);
            return this._loadInternal(ids, loadOperation)
                .then(() => {
                const result = BluebirdPromise.resolve(loadOperation.getDocuments(objType))
                    .then(docs => {
                    if (isLoadingSingle) {
                        return docs[Object.keys(docs)[0]];
                    }
                    return docs;
                })
                    .tap((entities) => callback(null, entities))
                    .tapCatch(err => callback(err));
                return Promise.resolve(result);
            });
        });
    }
    _loadInternal(ids, operation) {
        operation.byIds(ids);
        const command = operation.createRequest();
        return Promise.resolve()
            .then(() => {
            if (command) {
                return this._requestExecutor.execute(command, this._sessionInfo)
                    .then(() => operation.setResult(command.result));
            }
        });
    }
    saveChanges(callback) {
        callback = callback || TypeUtil_1.TypeUtil.NOOP;
        const saveChangeOperation = new BatchOperation_1.BatchOperation(this);
        let command;
        const result = BluebirdPromise.resolve()
            .then(() => command = saveChangeOperation.createRequest())
            .then(() => {
            if (!command) {
                return;
            }
            return this._requestExecutor.execute(command, this._sessionInfo)
                .then(() => saveChangeOperation.setResult(command.result));
        })
            .finally(() => {
            if (command) {
                command.dispose();
            }
        })
            .tap(() => callback())
            .tapCatch(err => callback(err));
        return Promise.resolve(result);
    }
    refresh(entity) {
        const documentInfo = this.documentsByEntity.get(entity);
        if (!documentInfo) {
            Exceptions_1.throwError("InvalidOperationException", "Cannot refresh a transient instance");
        }
        this.incrementRequestCount();
        const command = new GetDocumentsCommand_1.GetDocumentsCommand({ id: documentInfo.id });
        return Promise.resolve()
            .then(() => this._requestExecutor.execute(command, this._sessionInfo))
            .then(() => this._refreshInternal(entity, command, documentInfo));
    }
    exists(id) {
        if (!id) {
            return Promise.reject(Exceptions_1.getError("InvalidArgumentException", "id cannot be null"));
        }
        if (this.documentsById.getValue(id)) {
            return Promise.resolve(true);
        }
        const command = new HeadDocumentCommand_1.HeadDocumentCommand(id, null);
        return Promise.resolve()
            .then(() => this._requestExecutor.execute(command, this._sessionInfo))
            .then(() => !TypeUtil_1.TypeUtil.isNullOrUndefined(command.result));
    }
    loadStartingWith(idPrefix, optsOrCallback, callback) {
        const loadStartingWithOperation = new LoadStartingWithOperation_1.LoadStartingWithOperation(this);
        let opts;
        if (TypeUtil_1.TypeUtil.isFunction(optsOrCallback)) {
            callback = optsOrCallback;
        }
        else {
            opts = optsOrCallback;
        }
        opts = opts || {};
        callback = callback || TypeUtil_1.TypeUtil.NOOP;
        const result = BluebirdPromise.resolve()
            .then(() => this._loadStartingWithInternal(idPrefix, loadStartingWithOperation, opts))
            .then(() => loadStartingWithOperation.getDocuments(opts.documentType))
            .tap(results => callback(null, results))
            .tapCatch(err => callback(err));
        return Promise.resolve(result);
    }
    _loadStartingWithInternal(idPrefix, operation, opts) {
        const { matches, start, pageSize, exclude, startAfter } = opts || {};
        operation.withStartWith(idPrefix, {
            matches, start, pageSize, exclude, startAfter
        });
        const command = operation.createRequest();
        return Promise.resolve()
            .then(() => {
            if (command) {
                return this._requestExecutor.execute(command, this._sessionInfo);
            }
        })
            .then(() => {
            operation.setResult(command.result);
            return command;
        });
    }
    loadInternal(ids, includes, documentType) {
        const loadOperation = new LoadOperation_1.LoadOperation(this);
        loadOperation.byIds(ids);
        loadOperation.withIncludes(includes);
        const command = loadOperation.createRequest();
        return Promise.resolve()
            .then(() => {
            if (command) {
                return this._requestExecutor.execute(command, this._sessionInfo)
                    .then(() => loadOperation.setResult(command.result));
            }
            return;
        })
            .then(() => {
            const clazz = this.conventions.findEntityType(documentType);
            return loadOperation.getDocuments(clazz);
        });
    }
    include(path) {
        return new MultiLoaderWithInclude_1.MultiLoaderWithInclude(this).include(path);
    }
    rawQuery(query, documentType) {
        if (documentType) {
            this.conventions.tryRegisterEntityType(documentType);
        }
        return new RawDocumentQuery_1.RawDocumentQuery(this, query, documentType);
    }
    query(docTypeOrOpts) {
        if (TypeUtil_1.TypeUtil.isDocumentType(docTypeOrOpts)) {
            return this.documentQuery({
                documentType: docTypeOrOpts
            });
        }
        return this.documentQuery(docTypeOrOpts);
    }
    documentQuery(documentTypeOrOpts) {
        let opts;
        if (TypeUtil_1.TypeUtil.isDocumentType(documentTypeOrOpts)) {
            opts = { documentType: documentTypeOrOpts };
        }
        else {
            opts = documentTypeOrOpts;
        }
        if (opts.documentType) {
            this.conventions.tryRegisterEntityType(opts.documentType);
        }
        const { indexName, collection } = this._processQueryParameters(opts, this.conventions);
        return new DocumentQuery_1.DocumentQuery(opts.documentType, this, indexName, collection, !!opts.isMapReduce);
    }
    _processQueryParameters(opts, conventions) {
        let { indexName, collection } = opts;
        const isIndex = !!indexName;
        const isCollection = !!collection;
        if (isIndex && isCollection) {
            Exceptions_1.throwError("InvalidOperationException", "Parameters indexName and collectionName are mutually exclusive. Please specify only one of them.");
        }
        if (!isIndex && !isCollection) {
            const entityType = this.conventions.findEntityType(opts.documentType);
            collection = this.conventions.getCollectionNameForType(entityType);
        }
        return { indexName, collection };
    }
}
exports.DocumentSession = DocumentSession;
