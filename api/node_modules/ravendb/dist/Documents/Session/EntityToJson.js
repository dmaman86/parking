"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const TypeUtil_1 = require("../../Utility/TypeUtil");
const Constants_1 = require("../../Constants");
const Mapping_1 = require("../../Mapping");
const Exceptions_1 = require("../../Exceptions");
class EntityToJson {
    constructor(session) {
        this._missingDictionary = new Map();
        this._session = session;
    }
    get missingDictionary() {
        return this._missingDictionary;
    }
    convertEntityToJson(entity, documentInfo) {
        const { conventions } = this._session;
        const entityMapper = conventions.entityObjectMapper;
        let typeInfo;
        const jsonNode = entityMapper.toObjectLiteral(entity, (_typeInfo) => {
            typeInfo = _typeInfo;
        }, conventions.knownEntityTypesByName);
        EntityToJson._writeMetadata(jsonNode, typeInfo, documentInfo);
        const type = TypeUtil_1.TypeUtil.findType(entity, conventions.knownEntityTypes);
        EntityToJson._tryRemoveIdentityProperty(jsonNode, type, conventions);
        return jsonNode;
    }
    static convertEntityToJson(entity, conventions, documentInfo) {
        let typeInfo;
        const jsonNode = Mapping_1.Mapping.getDefaultMapper().toObjectLiteral(entity, (_typeInfo) => {
            typeInfo = _typeInfo;
        });
        EntityToJson._writeMetadata(jsonNode, typeInfo, documentInfo);
        EntityToJson._tryRemoveIdentityProperty(jsonNode, typeInfo.typeName, conventions);
        return jsonNode;
    }
    static _writeMetadata(jsonNode, typeInfo, documentInfo) {
        if (!documentInfo) {
            return;
        }
        documentInfo.metadata[Constants_1.CONSTANTS.Documents.Metadata.NESTED_OBJECT_TYPES] =
            typeInfo.nestedTypes;
        documentInfo.metadata[Constants_1.CONSTANTS.Documents.Metadata.RAVEN_JS_TYPE] =
            typeInfo.typeName;
        let setMetadata = false;
        const metadataNode = {};
        if (documentInfo.metadata
            && Object.keys(documentInfo.metadata).length > 0) {
            setMetadata = true;
            Object.assign(metadataNode, documentInfo.metadata);
        }
        if (documentInfo.collection) {
            setMetadata = true;
            metadataNode[Constants_1.CONSTANTS.Documents.Metadata.COLLECTION] = documentInfo.collection;
        }
        if (setMetadata) {
            jsonNode[Constants_1.CONSTANTS.Documents.Metadata.KEY] = metadataNode;
        }
    }
    convertToEntity(targetEntityType, id, document) {
        const conventions = this._session.conventions;
        const entityType = conventions.findEntityType(targetEntityType);
        try {
            if (TypeUtil_1.TypeUtil.isType(document, targetEntityType)) {
                return document;
            }
            let entity;
            const documentTypeFromConventions = conventions.getJsType(id, document);
            const entityTypeInfoFromMetadata = EntityToJson._getEntityTypeInfoFromMetadata(document);
            if (documentTypeFromConventions) {
                const passedEntityTypeIsAssignableFromConventionsDocType = entityType
                    && ((entityType.name === documentTypeFromConventions.name)
                        || TypeUtil_1.TypeUtil.isInstanceOf(entityType, documentTypeFromConventions));
                if (passedEntityTypeIsAssignableFromConventionsDocType) {
                    const mapper = this._session.conventions.entityObjectMapper;
                    entity = mapper.fromObjectLiteral(document, entityTypeInfoFromMetadata, this._session.conventions.knownEntityTypesByName);
                }
            }
            if (!entity) {
                const mapper = this._session.conventions.entityObjectMapper;
                let passedTypeInfo = entityTypeInfoFromMetadata;
                if (entityType) {
                    passedTypeInfo =
                        Object.assign(passedTypeInfo, { typeName: entityType.name });
                }
                entity = mapper.fromObjectLiteral(document, passedTypeInfo, this._session.conventions.knownEntityTypesByName);
            }
            if (id) {
                this._session.generateEntityIdOnTheClient.trySetIdentity(entity, id);
            }
            return entity;
        }
        catch (err) {
            Exceptions_1.throwError("InvalidOperationException", `Could not convert document ${id} to entity of type `
                + `${entityType ? entityType.name : entityType}: ${err.stack}`, err);
        }
    }
    static _getEntityTypeInfoFromMetadata(document) {
        const metadata = document[Constants_1.CONSTANTS.Documents.Metadata.KEY];
        if (!metadata) {
            return {};
        }
        return {
            typeName: metadata[Constants_1.CONSTANTS.Documents.Metadata.RAVEN_JS_TYPE],
            nestedTypes: metadata[Constants_1.CONSTANTS.Documents.Metadata.NESTED_OBJECT_TYPES]
        };
    }
    static _tryRemoveIdentityProperty(document, entityType, conventions) {
        const identityProperty = conventions.getIdentityProperty(entityType);
        if (!identityProperty) {
            return false;
        }
        delete document[identityProperty];
        return true;
    }
}
exports.EntityToJson = EntityToJson;
