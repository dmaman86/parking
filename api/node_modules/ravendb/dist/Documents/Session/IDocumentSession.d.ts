import { DocumentConventions } from "../Conventions/DocumentConventions";
import { IDisposable } from "../../Types/Contracts";
import { AbstractCallback } from "../../Types/Callbacks";
import { RequestExecutor } from "../../Http/RequestExecutor";
import { DocumentType } from "../DocumentAbstractions";
import { EntitiesCollectionObject, ObjectTypeDescriptor } from "../../Types";
import { IAdvancedSessionOperations } from "./IAdvancedSessionOperations";
import { ILoaderWithInclude } from "./Loaders/ILoaderWithInclude";
import { DocumentQueryOptions } from "./QueryOptions";
import { IDocumentQuery } from "./IDocumentQuery";
export declare class SessionInfo {
    sessionId: number;
    constructor(sessionId?: number);
}
export interface IMetadataDictionary {
    [key: string]: Object;
}
export declare type ConcurrencyCheckMode = "Auto" | "Forced" | "Disabled";
export interface IDocumentSessionImpl {
    conventions: DocumentConventions;
}
export interface IDocumentSession extends IDisposable {
    advanced: IAdvancedSessionOperations;
    load<TEntity extends object>(id: string, callback?: AbstractCallback<TEntity>): Promise<TEntity>;
    load<TEntity extends object>(id: string, documentType?: DocumentType<TEntity>, callback?: AbstractCallback<TEntity>): Promise<TEntity>;
    load<TEntity extends object>(id: string, options?: LoadOptions<TEntity>, callback?: AbstractCallback<TEntity>): Promise<TEntity>;
    load<TEntity extends object>(ids: string[], callback?: AbstractCallback<EntitiesCollectionObject<TEntity>>): Promise<EntitiesCollectionObject<TEntity>>;
    load<TEntity extends object>(ids: string[], documentType?: DocumentType<TEntity>, callback?: AbstractCallback<TEntity>): Promise<EntitiesCollectionObject<TEntity>>;
    load<TEntity extends object>(ids: string[], options?: LoadOptions<TEntity>, callback?: AbstractCallback<TEntity>): Promise<EntitiesCollectionObject<TEntity>>;
    delete<TEntity extends object>(id: string): Promise<void>;
    delete<TEntity extends object>(id: string, expectedChangeVector: string): Promise<void>;
    delete<TEntity extends object>(entity: TEntity): Promise<void>;
    store<TEntity extends object>(document: TEntity, callback?: AbstractCallback<void>): Promise<void>;
    store<TEntity extends object>(document: TEntity, id?: string, callback?: AbstractCallback<void>): Promise<void>;
    store<TEntity extends object>(document: TEntity, id?: string, documentType?: DocumentType<TEntity>, callback?: AbstractCallback<void>): Promise<void>;
    store<TEntity extends object>(document: TEntity, id?: string, options?: StoreOptions<TEntity>, callback?: AbstractCallback<void>): Promise<void>;
    include(path: string): ILoaderWithInclude;
    saveChanges(): Promise<void>;
    saveChanges(callback: AbstractCallback<void>): Promise<void>;
    query<T extends object>(opts: DocumentQueryOptions<T>): IDocumentQuery<T>;
    query<T extends object>(documentType: DocumentType<T>): IDocumentQuery<T>;
}
export interface ISessionOptions {
    database?: string;
    requestExecutor?: RequestExecutor;
}
export interface StoreOptions<T extends object> {
    documentType?: DocumentType<T>;
    changeVector?: string;
}
export interface LoadOptions<T extends object> {
    documentType?: DocumentType<T>;
    includes?: string[];
    expectedChangeVector?: string;
}
export interface SessionLoadStartingWithOptions<T extends object> extends StartingWithOptions {
    documentType?: DocumentType<T>;
    matches?: string;
    start?: number;
    pageSize?: number;
    exclude?: string;
    startAfter?: string;
}
export interface StartingWithOptions {
    matches?: string;
    start?: number;
    pageSize?: number;
    exclude?: string;
    startAfter?: string;
}
export interface IDocumentSessionImpl extends IDocumentSession {
    conventions: DocumentConventions;
    loadInternal<TResult extends object>(ids: string[], includes: string[], clazz: ObjectTypeDescriptor<TResult>): Promise<EntitiesCollectionObject<TResult>>;
}
