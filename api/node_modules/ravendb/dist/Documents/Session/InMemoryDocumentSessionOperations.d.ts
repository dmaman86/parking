/// <reference types="node" />
import { EntityToJson } from "./EntityToJson";
import { IDisposable } from "../../Types/Contracts";
import { IMetadataDictionary, SessionInfo, ConcurrencyCheckMode, StoreOptions } from "./IDocumentSession";
import { ObjectTypeDescriptor } from "../../Types";
import { SessionEventsEmitter } from "./SessionEvents";
import { RequestExecutor } from "../../Http/RequestExecutor";
import { IDocumentStore } from "../IDocumentStore";
import { ServerNode } from "../../Http/ServerNode";
import { DocumentsById } from "./DocumentsById";
import { DocumentInfo } from "./DocumentInfo";
import { DocumentStoreBase } from "../DocumentStoreBase";
import { ICommandData, SaveChangesData } from "../Commands/CommandData";
import { GenerateEntityIdOnTheClient } from "../Identity/GenerateEntityIdOnTheClient";
import { AbstractCallback } from "../../Types/Callbacks";
import { DocumentType } from "../DocumentAbstractions";
import { DocumentsChanges } from "./DocumentsChanges";
import { EventEmitter } from "events";
import { IRavenObject } from "../../Types/IRavenObject";
import { GetDocumentsResult } from "../Commands/GetDocumentsCommand";
import { DocumentConventions } from "../Conventions/DocumentConventions";
import { RavenCommand } from "../../Http/RavenCommand";
import { JsonSerializer } from "../../Mapping/Json/Serializer";
export declare abstract class InMemoryDocumentSessionOperations extends EventEmitter implements IDisposable, SessionEventsEmitter {
    private static _clientSessionIdCounter;
    protected _clientSessionId: number;
    protected _requestExecutor: RequestExecutor;
    protected _pendingLazyOperations: any[];
    protected static _instancesCounter: number;
    private _hash;
    private _disposed;
    protected _jsonSerializer: JsonSerializer;
    private _id;
    readonly id: string;
    protected deletedEntities: Set<object>;
    protected _knownMissingIds: Set<string>;
    private _externalState;
    readonly externalState: Map<string, object>;
    getCurrentSessionNode(): Promise<ServerNode>;
    documentsById: DocumentsById;
    includedDocumentsById: Map<string, DocumentInfo>;
    documentsByEntity: Map<object, DocumentInfo>;
    protected _documentStore: DocumentStoreBase;
    private _databaseName;
    private _saveChangesOptions;
    readonly databaseName: string;
    readonly documentStore: IDocumentStore;
    readonly requestExecutor: RequestExecutor;
    private _numberOfRequests;
    readonly numberOfRequests: number;
    getNumberOfEntitiesInUnitOfWork(): number;
    readonly storeIdentifier: string;
    readonly conventions: DocumentConventions;
    maxNumberOfRequestsPerSession: number;
    useOptimisticConcurrency: boolean;
    protected _deferredCommands: ICommandData[];
    protected _deferredCommandsMap: Map<string, ICommandData>;
    readonly deferredCommandsCount: number;
    private _generateEntityIdOnTheClient;
    readonly generateEntityIdOnTheClient: GenerateEntityIdOnTheClient;
    private _entityToJson;
    readonly entityToJson: EntityToJson;
    protected _sessionInfo: SessionInfo;
    readonly sessionInfo: SessionInfo;
    protected constructor(databaseName: string, documentStore: DocumentStoreBase, requestExecutor: RequestExecutor, id: string);
    protected abstract _generateId(entity: object): Promise<string>;
    getMetadataFor<T extends object>(instance: T): IMetadataDictionary;
    private _getDocumentInfo<T>(instance);
    protected _assertNoNonUniqueInstance(entity: object, id: string): void;
    getChangeVectorFor<T extends object>(instance: T): string;
    getLastModifiedFor<T extends object>(instance: T): Date;
    isLoaded(id: string): boolean;
    isLoadedOrDeleted(id: string): boolean;
    isDeleted(id: string): boolean;
    getDocumentId(instance: object): string;
    incrementRequestCount(): void;
    checkIfIdAlreadyIncluded(ids: string[], includes: Map<string, ObjectTypeDescriptor>): boolean;
    checkIfIdAlreadyIncluded(ids: string[], includes: string[]): boolean;
    trackEntity<T extends object>(entityType: ObjectTypeDescriptor<T>, documentFound: DocumentInfo): T;
    trackEntity<T extends object>(entityType: ObjectTypeDescriptor<T>, id: string, document: object, metadata: object, noTracking: boolean): object;
    private _deserializeFromTransformer(clazz, id, document);
    registerIncludes(includes: object): void;
    registerMissingIncludes(results: object[], includes: object, includePaths: string[]): void;
    registerMissing(id: string): void;
    unregisterMissing(id: string): void;
    store<TEntity extends object>(entity: TEntity): Promise<void>;
    store<TEntity extends object>(entity: TEntity, callback?: AbstractCallback<void>): Promise<void>;
    store<TEntity extends object>(entity: TEntity, id?: string, callback?: AbstractCallback<void>): Promise<void>;
    store<TEntity extends object>(entity: TEntity, id?: string, documentType?: DocumentType<TEntity>, callback?: AbstractCallback<void>): Promise<void>;
    store<TEntity extends object>(entity: TEntity, id?: string, options?: StoreOptions<TEntity>, callback?: AbstractCallback<void>): Promise<void>;
    protected _generateDocumentKeysOnStore: boolean;
    private _storeInternal(entity, changeVector, id, forceConcurrencyCheck, documentType);
    protected _storeEntityInUnitOfWork(id: string, entity: object, changeVector: string, metadata: object, forceConcurrencyCheck: ConcurrencyCheckMode, documentType: DocumentType): void;
    protected _rememberEntityForDocumentIdGeneration(entity: object): void;
    prepareForSaveChanges(): SaveChangesData;
    private _newSaveChangesData();
    private _prepareForEntitiesDeletion(result, changes);
    private _prepareForEntitiesPuts(result);
    protected _entityChanged(newObj: object, documentInfo: DocumentInfo, changes: {
        [id: string]: DocumentsChanges[];
    }): boolean;
    private static _throwInvalidModifiedDocumentWithDeferredCommand(resultCommand);
    private static _throwInvalidDeletedDocumentWithDeferredCommand(resultCommand);
    private static _updateMetadataModifications(documentInfo);
    delete(id: string): Promise<void>;
    delete(id: string, expectedChangeVector: string): Promise<void>;
    delete<TEntity extends IRavenObject>(entity: TEntity): Promise<void>;
    private _deleteByEntity<TEntity>(entity);
    private _deleteById(id);
    private _deleteById(id, expectedChangeVector);
    defer(...commands: ICommandData[]): void;
    private _deferInternal(command);
    protected _refreshInternal<T extends object>(entity: T, cmd: RavenCommand<GetDocumentsResult>, documentInfo: DocumentInfo): void;
    hasChanges(): boolean;
    evict<T extends object>(entity: T): void;
    clear(): void;
    hasChanged(entity: object): boolean;
    ignoreChangesFor(entity: object): void;
    whatChanged(): {
        [id: string]: DocumentsChanges[];
    };
    private _getAllEntitiesChanges(changes);
    dispose(isDisposing?: boolean): void;
}
