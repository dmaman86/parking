"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BluebirdPromise = require("bluebird");
const EntityToJson_1 = require("./EntityToJson");
const IDocumentSession_1 = require("./IDocumentSession");
const SessionEvents_1 = require("./SessionEvents");
const Exceptions_1 = require("../../Exceptions");
const DocumentsById_1 = require("./DocumentsById");
const DocumentInfo_1 = require("./DocumentInfo");
const CommandData_1 = require("../Commands/CommandData");
const GenerateEntityIdOnTheClient_1 = require("../Identity/GenerateEntityIdOnTheClient");
const Json_1 = require("../../Mapping/Json");
const Constants_1 = require("../../Constants");
const DateUtil_1 = require("../../Utility/DateUtil");
const IncludesUtil_1 = require("./IncludesUtil");
const TypeUtil_1 = require("../../Utility/TypeUtil");
const IdTypeAndName_1 = require("../IdTypeAndName");
const DocumentsChanges_1 = require("./DocumentsChanges");
const events_1 = require("events");
const JsonOperation_1 = require("../../Mapping/JsonOperation");
const Serializer_1 = require("../../Mapping/Json/Serializer");
class InMemoryDocumentSessionOperations extends events_1.EventEmitter {
    constructor(databaseName, documentStore, requestExecutor, id) {
        super();
        this._clientSessionId = ++InMemoryDocumentSessionOperations._clientSessionIdCounter;
        this._pendingLazyOperations = [];
        this._hash = ++InMemoryDocumentSessionOperations._instancesCounter;
        this._jsonSerializer = Serializer_1.JsonSerializer.getDefaultForCommandPayload();
        this.deletedEntities = new Set();
        this._knownMissingIds = new Set();
        this.documentsById = new DocumentsById_1.DocumentsById();
        this.includedDocumentsById = new Map();
        this.documentsByEntity = new Map();
        this._numberOfRequests = 0;
        this._deferredCommands = [];
        this._deferredCommandsMap = new Map();
        this._generateDocumentKeysOnStore = true;
        this._id = id;
        this._databaseName = databaseName;
        this._documentStore = documentStore;
        this._requestExecutor = requestExecutor;
        this.useOptimisticConcurrency = this._requestExecutor.conventions.isUseOptimisticConcurrency();
        this.maxNumberOfRequestsPerSession = this._requestExecutor.conventions.maxNumberOfRequestsPerSession;
        this._generateEntityIdOnTheClient =
            new GenerateEntityIdOnTheClient_1.GenerateEntityIdOnTheClient(this._requestExecutor.conventions, (obj) => this._generateId(obj));
        this._entityToJson = new EntityToJson_1.EntityToJson(this);
        this._sessionInfo = new IDocumentSession_1.SessionInfo(this._clientSessionId);
    }
    get id() {
        return this._id;
    }
    get externalState() {
        if (!this._externalState) {
            this._externalState = new Map();
        }
        return this._externalState;
    }
    getCurrentSessionNode() {
        let result;
        switch (this._documentStore.conventions.readBalanceBehavior) {
            case "None":
                result = this._requestExecutor.getPreferredNode();
                break;
            case "RoundRobin":
                result = this._requestExecutor.getNodeBySessionId(this._clientSessionId);
                break;
            case "FastestNode":
                result = this._requestExecutor.getFastestNode();
                break;
            default:
                return Promise.reject(Exceptions_1.getError("InvalidArgumentException", this._documentStore.conventions.readBalanceBehavior));
        }
        return result.then(x => x.currentNode);
    }
    get databaseName() {
        return this._databaseName;
    }
    get documentStore() {
        return this._documentStore;
    }
    get requestExecutor() {
        return this._requestExecutor;
    }
    get numberOfRequests() {
        return this._numberOfRequests;
    }
    getNumberOfEntitiesInUnitOfWork() {
        return this.documentsByEntity.size;
    }
    get storeIdentifier() {
        return `${this._documentStore.identifier};${this._databaseName}`;
    }
    get conventions() {
        return this._requestExecutor.conventions;
    }
    get deferredCommandsCount() {
        return this._deferredCommands.length;
    }
    get generateEntityIdOnTheClient() {
        return this._generateEntityIdOnTheClient;
    }
    get entityToJson() {
        return this._entityToJson;
    }
    get sessionInfo() {
        return this._sessionInfo;
    }
    getMetadataFor(instance) {
        if (!instance) {
            Exceptions_1.throwError("InvalidOperationException", "Instance cannot be null or undefined.");
        }
        const documentInfo = this._getDocumentInfo(instance);
        const metadataInstance = documentInfo.metadataInstance;
        if (metadataInstance) {
            return metadataInstance;
        }
        const metadata = documentInfo.metadata;
        documentInfo.metadataInstance = metadata;
        return metadata;
    }
    _getDocumentInfo(instance) {
        const documentInfo = this.documentsByEntity.get(instance);
        if (documentInfo) {
            return documentInfo;
        }
        let idRef;
        if (!this._generateEntityIdOnTheClient.tryGetIdFromInstance(instance, (_idRef) => idRef = _idRef)) {
            Exceptions_1.throwError("InvalidOperationException", "Could not find the document id for " + instance);
        }
        this._assertNoNonUniqueInstance(instance, idRef);
        Exceptions_1.throwError("InvalidArgumentException", "Document " + idRef + " doesn't exist in the session");
    }
    _assertNoNonUniqueInstance(entity, id) {
        if (!id
            || id[id.length - 1] === "|"
            || id[id.length - 1] === "/") {
            return;
        }
        const info = this.documentsById.getValue(id);
        if (!info || info.entity === entity) {
            return;
        }
        Exceptions_1.throwError("NonUniqueObjectException", "Attempted to associate a different object with id '" + id + "'.");
    }
    getChangeVectorFor(instance) {
        if (!instance) {
            Exceptions_1.throwError("InvalidArgumentException", "Instance cannot be null or undefined.");
        }
        const documentInfo = this._getDocumentInfo(instance);
        const changeVector = documentInfo.metadata[Constants_1.CONSTANTS.Documents.Metadata.CHANGE_VECTOR];
        if (changeVector) {
            return changeVector.toString();
        }
        return null;
    }
    getLastModifiedFor(instance) {
        if (!instance) {
            Exceptions_1.throwError("InvalidArgumentException", "Instance cannot be null or undefined.");
        }
        const documentInfo = this._getDocumentInfo(instance);
        const lastModified = documentInfo.metadata[Constants_1.CONSTANTS.Documents.Metadata.LAST_MODIFIED];
        return DateUtil_1.DateUtil.parse(lastModified);
    }
    isLoaded(id) {
        return this.isLoadedOrDeleted(id);
    }
    isLoadedOrDeleted(id) {
        const documentInfo = this.documentsById.getValue(id);
        return !!(documentInfo && documentInfo.document)
            || this.isDeleted(id)
            || this.includedDocumentsById.has(id);
    }
    isDeleted(id) {
        return this._knownMissingIds.has(id);
    }
    getDocumentId(instance) {
        if (!instance) {
            return null;
        }
        const value = this.documentsByEntity.get(instance);
        return value ? value.id : null;
    }
    incrementRequestCount() {
        if (++this._numberOfRequests > this.maxNumberOfRequestsPerSession) {
            Exceptions_1.throwError("InvalidOperationException", `The maximum number of requests (${this.maxNumberOfRequestsPerSession}) allowed for this session has been reached.` +
                "Raven limits the number of remote calls that a session is allowed to make as an early warning system. Sessions are expected to be short lived, and " +
                "Raven provides facilities like load(String[] keys) to load multiple documents at once and batch saves (call SaveChanges() only once)." +
                "You can increase the limit by setting DocumentConvention.MaxNumberOfRequestsPerSession or MaxNumberOfRequestsPerSession, but it is" +
                "advisable that you'll look into reducing the number of remote calls first, since that will speed up your application significantly and result in a" +
                "more responsive application.");
        }
    }
    checkIfIdAlreadyIncluded(ids, includes) {
        let includesList;
        if (includes instanceof Map) {
            includesList = Array.from(includes.keys());
        }
        for (const id of ids) {
            if (this._knownMissingIds.has(id)) {
                continue;
            }
            let documentInfo = this.documentsById.getValue(id);
            if (!documentInfo) {
                documentInfo = this.includedDocumentsById.get(id);
                if (!documentInfo) {
                    return false;
                }
            }
            if (!documentInfo.entity) {
                return false;
            }
            if (!includes) {
                continue;
            }
            for (const include of includesList) {
                let hasAll = true;
                IncludesUtil_1.IncludesUtil.include(documentInfo.document, include, (id) => {
                    hasAll = hasAll && this.isLoaded(id);
                });
                if (!hasAll[0]) {
                    return false;
                }
            }
        }
        return true;
    }
    trackEntity(entityType, idOrDocumentInfo, document, metadata, noTracking) {
        let id;
        if (TypeUtil_1.TypeUtil.isObject(idOrDocumentInfo)) {
            const info = idOrDocumentInfo;
            return this.trackEntity(entityType, info.id, info.document, info.metadata, false);
        }
        else {
            id = idOrDocumentInfo;
        }
        if (!id) {
            return this._deserializeFromTransformer(entityType, null, document);
        }
        let docInfo = this.documentsById.getValue(id);
        if (docInfo) {
            if (!docInfo.entity) {
                docInfo.entity = this.entityToJson.convertToEntity(entityType, id, document);
            }
            if (!noTracking) {
                this.includedDocumentsById.delete(id);
                this.documentsByEntity.set(docInfo.entity, docInfo);
            }
            return docInfo.entity;
        }
        docInfo = this.includedDocumentsById.get(id);
        if (docInfo) {
            if (!docInfo.entity) {
                docInfo.entity = this.entityToJson.convertToEntity(entityType, id, document);
            }
            if (!noTracking) {
                this.includedDocumentsById.delete(id);
                this.documentsById.add(docInfo);
                this.documentsByEntity.set(docInfo.entity, docInfo);
            }
            return docInfo.entity;
        }
        const entity = this.entityToJson.convertToEntity(entityType, id, document);
        const changeVector = metadata[Constants_1.CONSTANTS.Documents.Metadata.CHANGE_VECTOR];
        if (!changeVector) {
            Exceptions_1.throwError("InvalidOperationException", "Document " + id + " must have Change Vector.");
        }
        if (!noTracking) {
            const newDocumentInfo = new DocumentInfo_1.DocumentInfo();
            newDocumentInfo.id = id;
            newDocumentInfo.document = document;
            newDocumentInfo.metadata = metadata;
            newDocumentInfo.entity = entity;
            newDocumentInfo.changeVector = changeVector;
            this.documentsById.add(newDocumentInfo);
            this.documentsByEntity.set(entity, newDocumentInfo);
        }
        return entity;
    }
    _deserializeFromTransformer(clazz, id, document) {
        return this.entityToJson.convertToEntity(clazz, id, document);
    }
    registerIncludes(includes) {
        if (!includes) {
            return;
        }
        for (const fieldName of Object.keys(includes)) {
            const fieldValue = includes[fieldName];
            if (TypeUtil_1.TypeUtil.isNullOrUndefined(fieldValue)) {
                continue;
            }
            const newDocumentInfo = DocumentInfo_1.DocumentInfo.getNewDocumentInfo(fieldValue);
            if (Json_1.tryGetConflict(newDocumentInfo.metadata)) {
                continue;
            }
            this.includedDocumentsById.set(newDocumentInfo.id, newDocumentInfo);
        }
    }
    registerMissingIncludes(results, includes, includePaths) {
        if (!includePaths || !includePaths.length) {
            return;
        }
        for (const result of results) {
            for (const include of includePaths) {
                if (include === Constants_1.CONSTANTS.Documents.Indexing.Fields.DOCUMENT_ID_FIELD_NAME) {
                    continue;
                }
                IncludesUtil_1.IncludesUtil.include(result, include, id => {
                    if (!id) {
                        return;
                    }
                    if (this.isLoaded(id)) {
                        return;
                    }
                    const document = includes[id];
                    if (document) {
                        const metadata = document.get(Constants_1.CONSTANTS.Documents.Metadata.KEY);
                        if (Json_1.tryGetConflict(metadata)) {
                            return;
                        }
                    }
                    this.registerMissing(id);
                });
            }
        }
    }
    registerMissing(id) {
        this._knownMissingIds.add(id.toLowerCase());
    }
    unregisterMissing(id) {
        this._knownMissingIds.delete(id.toLowerCase());
    }
    store(entity, idOrCallback, docTypeOrOptionsOrCallback, callback) {
        let id = null;
        let documentType = null;
        let options = {};
        if (TypeUtil_1.TypeUtil.isString(idOrCallback) || !idOrCallback) {
            id = idOrCallback;
        }
        else if (TypeUtil_1.TypeUtil.isFunction(idOrCallback)) {
            callback = idOrCallback;
        }
        else {
            Exceptions_1.throwError("InvalidArgumentException", "Invalid 2nd parameter: must be id string or callback.");
        }
        if (TypeUtil_1.TypeUtil.isDocumentType(docTypeOrOptionsOrCallback)) {
            documentType = docTypeOrOptionsOrCallback;
        }
        else if (TypeUtil_1.TypeUtil.isFunction(docTypeOrOptionsOrCallback)) {
            callback = docTypeOrOptionsOrCallback;
        }
        else if (TypeUtil_1.TypeUtil.isObject(docTypeOrOptionsOrCallback)) {
            options = docTypeOrOptionsOrCallback;
        }
        callback = callback || TypeUtil_1.TypeUtil.NOOP;
        const changeVector = options.changeVector;
        documentType = documentType || options.documentType;
        this.conventions.tryRegisterEntityType(documentType);
        if (entity.constructor !== Object) {
            this.conventions.tryRegisterEntityType(entity.constructor);
        }
        let forceConcurrencyCheck;
        if (!TypeUtil_1.TypeUtil.isUndefined(changeVector)) {
            forceConcurrencyCheck = changeVector === null ? "Disabled" : "Forced";
        }
        else if (!TypeUtil_1.TypeUtil.isNullOrUndefined(id)) {
            forceConcurrencyCheck = "Auto";
        }
        else {
            const hasId = this._generateEntityIdOnTheClient.tryGetIdFromInstance(entity);
            forceConcurrencyCheck = !hasId ? "Forced" : "Auto";
        }
        const result = BluebirdPromise.resolve()
            .then(() => this._storeInternal(entity, changeVector, id, forceConcurrencyCheck, documentType))
            .tap(() => callback())
            .tapCatch(err => callback(err));
        return Promise.resolve(result);
    }
    _storeInternal(entity, changeVector, id, forceConcurrencyCheck, documentType) {
        if (!entity) {
            Exceptions_1.throwError("InvalidArgumentException", "Entity cannot be null or undefined.");
        }
        const value = this.documentsByEntity.get(entity);
        if (value) {
            value.changeVector = changeVector || value.changeVector;
            value.concurrencyCheckMode = forceConcurrencyCheck;
            return;
        }
        return Promise.resolve()
            .then(() => {
            if (!id) {
                if (this._generateDocumentKeysOnStore) {
                    return this._generateEntityIdOnTheClient.generateDocumentKeyForStorage(entity);
                }
                else {
                    this._rememberEntityForDocumentIdGeneration(entity);
                }
            }
            else {
                this.generateEntityIdOnTheClient.trySetIdentity(entity, id);
            }
            return id;
        })
            .then(id => {
            const cmdKey = IdTypeAndName_1.IdTypeAndName.keyFor(id, "ClientAnyCommand", null);
            if (this._deferredCommandsMap.has(cmdKey)) {
                Exceptions_1.throwError("InvalidOperationException", "Can't store document, there is a deferred command registered "
                    + "for this document in the session. Document id: " + id);
            }
            if (this.deletedEntities.has(entity)) {
                Exceptions_1.throwError("InvalidOperationException", "Can't store object, it was already deleted in this session.  Document id: " + id);
            }
            this._assertNoNonUniqueInstance(entity, id);
            const conventions = this._requestExecutor.conventions;
            const collectionName = conventions.getCollectionNameForEntity(entity);
            const metadata = {};
            if (collectionName) {
                metadata[Constants_1.CONSTANTS.Documents.Metadata.COLLECTION] = collectionName;
            }
            const entityType = documentType
                ? conventions.findEntityType(documentType)
                : conventions.getEntityTypeDescriptor(entity);
            const jsType = conventions.getJsTypeName(entityType);
            if (jsType) {
                metadata[Constants_1.CONSTANTS.Documents.Metadata.RAVEN_JS_TYPE] = jsType;
            }
            if (id) {
                this._knownMissingIds.delete(id);
            }
            this._storeEntityInUnitOfWork(id, entity, changeVector, metadata, forceConcurrencyCheck, documentType);
        });
    }
    _storeEntityInUnitOfWork(id, entity, changeVector, metadata, forceConcurrencyCheck, documentType) {
        this.deletedEntities.delete(entity);
        if (id) {
            this._knownMissingIds.delete(id);
        }
        const documentInfo = new DocumentInfo_1.DocumentInfo();
        documentInfo.id = id;
        documentInfo.metadata = metadata;
        documentInfo.changeVector = changeVector;
        documentInfo.concurrencyCheckMode = forceConcurrencyCheck;
        documentInfo.entity = entity;
        documentInfo.newDocument = true;
        documentInfo.document = null;
        this.documentsByEntity.set(entity, documentInfo);
        if (id) {
            this.documentsById.add(documentInfo);
        }
    }
    _rememberEntityForDocumentIdGeneration(entity) {
        Exceptions_1.throwError("NotImplementedException", "You cannot set GenerateDocumentIdsOnStore to false"
            + " without implementing RememberEntityForDocumentIdGeneration");
    }
    prepareForSaveChanges() {
        const result = this._newSaveChangesData();
        this._deferredCommands.length = 0;
        this._deferredCommandsMap.clear();
        this._prepareForEntitiesDeletion(result, null);
        this._prepareForEntitiesPuts(result);
        if (this._deferredCommands.length) {
            result.deferredCommands.push(...this._deferredCommands);
            for (const item of this._deferredCommandsMap.entries()) {
                const [key, value] = item;
                result.deferredCommandsMap.set(key, value);
            }
            this._deferredCommands.length = 0;
            this._deferredCommandsMap.clear();
        }
        return result;
    }
    _newSaveChangesData() {
        return new CommandData_1.SaveChangesData({
            deferredCommands: [...this._deferredCommands],
            deferredCommandsMap: new Map(this._deferredCommandsMap),
            options: this._saveChangesOptions
        });
    }
    _prepareForEntitiesDeletion(result, changes) {
        for (const deletedEntity of this.deletedEntities) {
            let documentInfo = this.documentsByEntity.get(deletedEntity);
            if (!documentInfo) {
                continue;
            }
            if (changes) {
                const docChanges = [];
                const change = new DocumentsChanges_1.DocumentsChanges();
                change.fieldNewValue = "";
                change.fieldOldValue = "";
                change.change = "DocumentDeleted";
                docChanges.push(change);
                changes[documentInfo.id] = docChanges;
            }
            else {
                const command = result.deferredCommandsMap.get(IdTypeAndName_1.IdTypeAndName.keyFor(documentInfo.id, "ClientAnyCommand", null));
                if (command) {
                    InMemoryDocumentSessionOperations._throwInvalidDeletedDocumentWithDeferredCommand(command);
                }
                let changeVector = null;
                documentInfo = this.documentsById.getValue(documentInfo.id);
                if (documentInfo) {
                    changeVector = documentInfo.changeVector;
                    if (documentInfo.entity) {
                        this.documentsByEntity.delete(documentInfo.entity);
                        result.entities.push(documentInfo.entity);
                    }
                    this.documentsById.remove(documentInfo.id);
                }
                changeVector = this.useOptimisticConcurrency ? changeVector : null;
                const beforeDeleteEventArgs = new SessionEvents_1.SessionBeforeDeleteEventArgs(this, documentInfo.id, documentInfo.entity);
                this.emit("beforeDelete", beforeDeleteEventArgs);
                result.sessionCommands.push(new CommandData_1.DeleteCommandData(documentInfo.id, changeVector));
            }
            if (!changes) {
                this.deletedEntities.clear();
            }
        }
    }
    _prepareForEntitiesPuts(result) {
        for (const entry of this.documentsByEntity.entries()) {
            const entity = {
                key: entry[0],
                value: entry[1]
            };
            InMemoryDocumentSessionOperations._updateMetadataModifications(entity.value);
            let document = this.entityToJson.convertEntityToJson(entity.key, entity.value);
            if (entity.value.ignoreChanges || !this._entityChanged(document, entity.value, null)) {
                continue;
            }
            const command = result.deferredCommandsMap.get(IdTypeAndName_1.IdTypeAndName.keyFor(entity.value.id, "ClientAnyCommand", null));
            if (command) {
                InMemoryDocumentSessionOperations._throwInvalidModifiedDocumentWithDeferredCommand(command);
            }
            const beforeStoreEventArgs = new SessionEvents_1.SessionBeforeStoreEventArgs(this, entity.value.id, entity.key);
            if (this.emit("beforeStore", beforeStoreEventArgs)) {
                if (beforeStoreEventArgs.isMetadataAccessed()) {
                    InMemoryDocumentSessionOperations._updateMetadataModifications(entity.value);
                }
                if (beforeStoreEventArgs.isMetadataAccessed() || this._entityChanged(document, entity.value, null)) {
                    document = this.entityToJson.convertEntityToJson(entity.key, entity.value);
                }
            }
            entity.value.newDocument = false;
            result.entities.push(entity.key);
            if (entity.value.id) {
                this.documentsById.remove(entity.value.id);
            }
            entity.value.document = document;
            let changeVector;
            if (this.useOptimisticConcurrency) {
                if (entity.value.concurrencyCheckMode !== "Disabled") {
                    changeVector = entity.value.changeVector || "";
                }
                else {
                    changeVector = null;
                }
            }
            else if (entity.value.concurrencyCheckMode === "Forced") {
                changeVector = entity.value.changeVector;
            }
            else {
                changeVector = null;
            }
            result.sessionCommands.push(new CommandData_1.PutCommandDataWithJson(entity.value.id, changeVector, document));
        }
    }
    _entityChanged(newObj, documentInfo, changes) {
        return JsonOperation_1.JsonOperation.entityChanged(newObj, documentInfo, changes);
    }
    static _throwInvalidModifiedDocumentWithDeferredCommand(resultCommand) {
        Exceptions_1.throwError("InvalidOperationException", "Cannot perform save because document " + resultCommand.id
            + " has been deleted by the session and is also taking part in deferred "
            + resultCommand.type + " command");
    }
    static _throwInvalidDeletedDocumentWithDeferredCommand(resultCommand) {
        Exceptions_1.throwError("InvalidOperationException", "Cannot perform save because document " + resultCommand.id
            + " has been deleted by the session and is also taking part in deferred "
            + resultCommand.type + " command");
    }
    static _updateMetadataModifications(documentInfo) {
        if (documentInfo.metadataInstance) {
            for (const prop of Object.keys(documentInfo.metadataInstance)) {
                documentInfo.metadata[prop] = documentInfo.metadataInstance[prop];
            }
        }
    }
    delete(idOrEntity, expectedChangeVector = null) {
        if (TypeUtil_1.TypeUtil.isString(idOrEntity)) {
            this._deleteById(idOrEntity, expectedChangeVector);
            return Promise.resolve();
        }
        this._deleteByEntity(idOrEntity);
        return Promise.resolve();
    }
    _deleteByEntity(entity) {
        if (!entity) {
            Exceptions_1.throwError("InvalidArgumentException", "Entity cannot be null.");
        }
        const value = this.documentsByEntity.get(entity);
        if (!value) {
            Exceptions_1.throwError("InvalidOperationException", entity + " is not associated with the session, cannot delete unknown entity instance");
        }
        this.deletedEntities.add(entity);
        this.includedDocumentsById.delete(value.id);
        this._knownMissingIds.add(value.id);
    }
    _deleteById(id, expectedChangeVector = null) {
        if (!id) {
            Exceptions_1.throwError("InvalidArgumentException", "Id cannot be null.");
        }
        let changeVector = null;
        const documentInfo = this.documentsById.getValue(id);
        if (documentInfo) {
            const newObj = this.entityToJson.convertEntityToJson(documentInfo.entity, documentInfo);
            if (documentInfo.entity && this._entityChanged(newObj, documentInfo, null)) {
                Exceptions_1.throwError("InvalidOperationException", "Can't delete changed entity using identifier. Use delete(T entity) instead.");
            }
            if (documentInfo.entity) {
                this.documentsByEntity.delete(documentInfo.entity);
            }
            this.documentsById.remove(id);
            changeVector = documentInfo.changeVector;
        }
        this._knownMissingIds.add(id);
        changeVector = this.useOptimisticConcurrency ? changeVector : null;
        this.defer(new CommandData_1.DeleteCommandData(id, expectedChangeVector || changeVector));
    }
    defer(...commands) {
        this._deferredCommands.push(...commands);
        for (const command of commands) {
            this._deferInternal(command);
        }
    }
    _deferInternal(command) {
        this._deferredCommandsMap.set(IdTypeAndName_1.IdTypeAndName.keyFor(command.id, command.type, command.name), command);
        this._deferredCommandsMap.set(IdTypeAndName_1.IdTypeAndName.keyFor(command.id, "ClientAnyCommand", null), command);
        if (command.type !== "AttachmentPUT") {
            this._deferredCommandsMap.set(IdTypeAndName_1.IdTypeAndName.keyFor(command.id, "ClientNotAttachmentPUT", null), command);
        }
    }
    _refreshInternal(entity, cmd, documentInfo) {
        const document = cmd.result.results[0];
        if (!document) {
            Exceptions_1.throwError("InvalidOperationException", "Document '" + documentInfo.id + "' no longer exists and was probably deleted");
        }
        const value = document[Constants_1.CONSTANTS.Documents.Metadata.KEY];
        documentInfo.metadata = value;
        if (documentInfo.metadata) {
            const changeVector = value[Constants_1.CONSTANTS.Documents.Metadata.CHANGE_VECTOR];
            documentInfo.changeVector = changeVector;
        }
        documentInfo.document = document;
        const entityType = this.conventions.getEntityTypeDescriptor(entity);
        documentInfo.entity = this.entityToJson.convertToEntity(entityType, documentInfo.id, document);
        Object.assign(entity, documentInfo.entity);
    }
    hasChanges() {
        for (const entity of this.documentsByEntity.entries()) {
            const document = this.entityToJson.convertEntityToJson(entity[0], entity[1]);
            if (this._entityChanged(document, entity[1], null)) {
                return true;
            }
        }
        return !this.deletedEntities.size;
    }
    evict(entity) {
        const documentInfo = this.documentsByEntity.get(entity);
        if (documentInfo) {
            this.documentsByEntity.delete(entity);
            this.documentsById.remove(documentInfo.id);
        }
        this.deletedEntities.delete(entity);
    }
    clear() {
        this.documentsByEntity.clear();
        this.deletedEntities.clear();
        this.documentsById.clear();
        this._knownMissingIds.clear();
        this.includedDocumentsById.clear();
    }
    hasChanged(entity) {
        const documentInfo = this.documentsByEntity.get(entity);
        if (!documentInfo) {
            return false;
        }
        const document = this.entityToJson.convertEntityToJson(entity, documentInfo);
        return this._entityChanged(document, documentInfo, null);
    }
    ignoreChangesFor(entity) {
        this._getDocumentInfo(entity).ignoreChanges = true;
    }
    whatChanged() {
        const changes = {};
        this._prepareForEntitiesDeletion(null, changes);
        this._getAllEntitiesChanges(changes);
        return changes;
    }
    _getAllEntitiesChanges(changes) {
        for (const pair of this.documentsById.entries()) {
            InMemoryDocumentSessionOperations._updateMetadataModifications(pair[1]);
            const newObj = this.entityToJson.convertEntityToJson(pair[1].entity, pair[1]);
            this._entityChanged(newObj, pair[1], changes);
        }
    }
    dispose(isDisposing) {
        if (this._disposed) {
            return;
        }
        this._disposed = true;
    }
}
InMemoryDocumentSessionOperations._clientSessionIdCounter = 0;
InMemoryDocumentSessionOperations._instancesCounter = 0;
exports.InMemoryDocumentSessionOperations = InMemoryDocumentSessionOperations;
