"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BatchCommand_1 = require("../../Commands/Batches/BatchCommand");
const Exceptions_1 = require("../../../Exceptions");
const Constants_1 = require("../../../Constants");
const SessionEvents_1 = require("../SessionEvents");
class BatchOperation {
    constructor(session) {
        this._session = session;
    }
    createRequest() {
        const result = this._session.prepareForSaveChanges();
        this._sessionCommandsCount = result.sessionCommands.length;
        result.sessionCommands.push(...result.deferredCommands);
        if (!result.sessionCommands.length) {
            return null;
        }
        this._session.incrementRequestCount();
        this._entities = result.entities;
        return new BatchCommand_1.BatchCommand(this._session.conventions, result.sessionCommands, result.options);
    }
    static _throwOnNullResults() {
        Exceptions_1.throwError("InvalidOperationException", "Received empty response from the server. This is not supposed to happen and is likely a bug.");
    }
    setResult(result) {
        if (!result.results) {
            BatchOperation._throwOnNullResults();
            return;
        }
        const results = result.results;
        for (let i = 0; i < this._sessionCommandsCount; i++) {
            const batchResult = results[0];
            if (!batchResult) {
                Exceptions_1.throwError("InvalidArgumentException", "result");
            }
            const type = batchResult.type;
            if (type !== "PUT") {
                continue;
            }
            const entity = this._entities[i];
            const documentInfo = this._session.documentsByEntity.get(entity);
            if (!documentInfo) {
                continue;
            }
            const changeVector = batchResult[Constants_1.CONSTANTS.Documents.Metadata.CHANGE_VECTOR];
            if (!changeVector) {
                Exceptions_1.throwError("InvalidOperationException", "PUT response is invalid. @change-vector is missing on " + documentInfo.id);
            }
            const id = batchResult[Constants_1.CONSTANTS.Documents.Metadata.ID];
            if (!id) {
                Exceptions_1.throwError("InvalidOperationException", "PUT response is invalid. @id is missing on " + documentInfo.id);
            }
            Object.keys(batchResult).forEach(propertyName => {
                if ("Type" === propertyName) {
                    return;
                }
                documentInfo.metadata[propertyName] = batchResult[propertyName];
            });
            documentInfo.id = id;
            documentInfo.changeVector = changeVector;
            documentInfo.document[Constants_1.CONSTANTS.Documents.Metadata.KEY] = documentInfo.metadata;
            documentInfo.metadataInstance = null;
            this._session.documentsById.add(documentInfo);
            this._session.generateEntityIdOnTheClient.trySetIdentity(entity, id);
            const afterSaveChangesEventArgs = new SessionEvents_1.SessionAfterSaveChangesEventArgs(this._session, documentInfo.id, documentInfo.entity);
            this._session.emit("afterSaveChanges", afterSaveChangesEventArgs);
        }
    }
}
exports.BatchOperation = BatchOperation;
