"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Stopwatch_1 = require("../../../Utility/Stopwatch");
const LogUtil_1 = require("../../../Utility/LogUtil");
const QueryCommand_1 = require("../../Commands/QueryCommand");
const Exceptions_1 = require("../../../Exceptions");
const StringBuilder = require("string-builder");
const Constants_1 = require("../../../Constants");
const TypeUtil_1 = require("../../../Utility/TypeUtil");
const log = LogUtil_1.getLogger({ module: "QueryOperation" });
class QueryOperation {
    constructor(session, indexName, indexQuery, fieldsToFetch, disableEntitiesTracking, metadataOnly, indexEntriesOnly) {
        this._session = session;
        this._indexName = indexName;
        this._indexQuery = indexQuery;
        this._fieldsToFetch = fieldsToFetch;
        this._disableEntitiesTracking = disableEntitiesTracking;
        this._metadataOnly = metadataOnly;
        this._indexEntriesOnly = indexEntriesOnly;
        this._assertPageSizeSet();
    }
    createRequest() {
        this._session.incrementRequestCount();
        this.logQuery();
        return new QueryCommand_1.QueryCommand(this._session.conventions, this._indexQuery, this._metadataOnly, this._indexEntriesOnly);
    }
    getCurrentQueryResults() {
        return this._currentQueryResults;
    }
    setResult(queryResult) {
        this.ensureIsAcceptableAndSaveResult(queryResult);
    }
    _assertPageSizeSet() {
        if (!this._session.conventions.isThrowIfQueryPageSizeIsNotSet()) {
            return;
        }
        if (this._indexQuery.pageSizeSet) {
            return;
        }
        Exceptions_1.throwError("InvalidOperationException", "Attempt to query without explicitly specifying a page size. " +
            "You can use .take() methods to set maximum number of results. " +
            "By default the page size is set to Integer.MAX_VALUE and can cause severe performance degradation.");
    }
    _startTiming() {
        this._sp = Stopwatch_1.Stopwatch.createStarted();
    }
    logQuery() {
        log.info("Executing query '" + this._indexQuery.query + "'"
            + (this._indexName ? "' on index '" + this._indexName + "'" : "")
            + " in " + this._session.storeIdentifier);
    }
    enterQueryContext() {
        this._startTiming();
        if (!this._indexQuery.waitForNonStaleResults) {
            return null;
        }
        return this._session.documentStore.disableAggressiveCaching(this._session.databaseName);
    }
    complete(documentType) {
        const queryResult = this._currentQueryResults.createSnapshot();
        if (!this._disableEntitiesTracking) {
            this._session.registerIncludes(queryResult.includes);
        }
        const list = [];
        try {
            for (const document of queryResult.results) {
                const metadata = document[Constants_1.CONSTANTS.Documents.Metadata.KEY];
                const idNode = metadata[Constants_1.CONSTANTS.Documents.Metadata.ID];
                let id = null;
                if (idNode && TypeUtil_1.TypeUtil.isString(idNode)) {
                    id = idNode;
                }
                list.push(QueryOperation.deserialize(id, document, metadata, this._fieldsToFetch, this._disableEntitiesTracking, this._session, documentType));
            }
        }
        catch (err) {
            log.warn(err, "Unable to read query result JSON.");
            Exceptions_1.throwError("RavenException", "Unable to read json.", err);
        }
        if (!this._disableEntitiesTracking) {
            this._session.registerMissingIncludes(queryResult.results, queryResult.includes, queryResult.includedPaths);
        }
        return list;
    }
    static deserialize(id, document, metadata, fieldsToFetch, disableEntitiesTracking, session, clazz) {
        const projection = metadata["@projection"];
        if (TypeUtil_1.TypeUtil.isNullOrUndefined(projection) || projection === false) {
            const entityType = session.conventions.findEntityType(clazz);
            return session.trackEntity(entityType, id, document, metadata, disableEntitiesTracking);
        }
        if (fieldsToFetch && fieldsToFetch.projections
            && fieldsToFetch.projections.length === 1
            && !clazz) {
            const projectField = fieldsToFetch.projections[0];
            const jsonNode = document[projectField];
            if (!TypeUtil_1.TypeUtil.isNullOrUndefined(jsonNode)
                && TypeUtil_1.TypeUtil.isPrimitive(jsonNode)) {
                return jsonNode || null;
            }
            const inner = document[projectField];
            if (TypeUtil_1.TypeUtil.isNullOrUndefined(inner)) {
                return null;
            }
            if (!TypeUtil_1.TypeUtil.isNullOrUndefined(fieldsToFetch.fieldsToFetch)
                && fieldsToFetch.fieldsToFetch[0] === fieldsToFetch.projections[0]) {
                if (TypeUtil_1.TypeUtil.isObject(inner)) {
                    document = inner;
                }
            }
        }
        const raw = session.conventions.entityObjectMapper
            .fromObjectLiteral(document);
        const projType = session.conventions.findEntityType(clazz);
        const projectionResult = projType
            ? new (Function.prototype.bind.apply(projType))
            : {};
        const result = fieldsToFetch && fieldsToFetch.projections
            ? fieldsToFetch.projections.reduce((reduced, key, i) => {
                reduced[key] = raw[fieldsToFetch.projections[i]];
                return reduced;
            }, projectionResult)
            : Object.assign(projectionResult, raw);
        if (id) {
            const identityProperty = session.conventions.getIdentityProperty(clazz);
            if (identityProperty) {
                const value = document[identityProperty];
                if (!value) {
                    session.generateEntityIdOnTheClient.trySetIdentity(result, id);
                }
            }
        }
        return result;
    }
    isDisableEntitiesTracking() {
        return this._disableEntitiesTracking;
    }
    setDisableEntitiesTracking(disableEntitiesTracking) {
        this._disableEntitiesTracking = disableEntitiesTracking;
    }
    ensureIsAcceptableAndSaveResult(result) {
        if (!result) {
            Exceptions_1.throwError("IndexDoesNotExistException", `Could not find index ${this._indexName}.`);
        }
        QueryOperation.ensureIsAcceptable(result, this._indexQuery.waitForNonStaleResults, this._sp, this._session);
        this._currentQueryResults = result;
        const isStale = result.isStale ? " stale " : " ";
        const parameters = new StringBuilder();
        if (this._indexQuery.queryParameters
            && this._indexQuery.queryParameters.length) {
            parameters.append("(parameters: ");
            let first = true;
            const queryParameters = this._indexQuery.queryParameters;
            for (const parameterKey of Object.keys(queryParameters)) {
                const parameterValue = queryParameters[parameterKey];
                if (!first) {
                    parameters.append(", ");
                }
                parameters.append(parameterKey)
                    .append(" = ")
                    .append(parameterValue);
                first = false;
            }
            parameters.append(") ");
        }
        log.info("Query '"
            + this._indexQuery.query + "' "
            + parameters.toString()
            + "returned "
            + result.results.length + isStale + "results (total index results: " + result.totalResults + ")");
    }
    static ensureIsAcceptable(result, waitForNonStaleResults, duration, session) {
        if (waitForNonStaleResults && result.isStale) {
            duration.stop();
            const msg = "Waited for " + duration.toString() + " for the query to return non stale result.";
            Exceptions_1.throwError("TimeoutException", msg);
        }
    }
    get indexQuery() {
        return this._indexQuery;
    }
}
exports.QueryOperation = QueryOperation;
