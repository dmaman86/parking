"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const verror_1 = require("verror");
const StatusCode_1 = require("../Http/StatusCode");
const Serializer_1 = require("../Mapping/Json/Serializer");
function printError(err) {
    return verror_1.VError.fullStack(err);
}
exports.printError = printError;
function throwError(errName = "RavenException", message, errCause, info) {
    throw getError(errName, message, errCause, info);
}
exports.throwError = throwError;
function getError(errName = "RavenException", message = "", errCause, info) {
    const error = new verror_1.VError({
        name: errName,
        cause: errCause,
        info
    }, message);
    return error;
}
exports.getError = getError;
class ExceptionDispatcher {
    static get(opts, code) {
        const { message, error, type } = opts;
        if (code === StatusCode_1.StatusCodes.Conflict) {
            if (type.indexOf("DocumentConflictException") !== -1) {
                return getError("DocumentConflictException", message);
            }
            return getError("ConcurrencyException", message);
        }
        const determinedType = this._getType(type);
        return getError(determinedType || "RavenException", error);
    }
    static throwException(response) {
        if (!response) {
            throw getError("InvalidArgumentException", "Response cannot be null");
        }
        let errorToThrow;
        try {
            const json = response.body;
            const schema = ExceptionDispatcher._jsonSerializer.deserialize(json);
            if (response.statusCode === StatusCode_1.StatusCodes.Conflict) {
                errorToThrow = this._getConflictError(schema, json);
            }
            else {
                const determinedType = this._getType(schema.type);
                errorToThrow = getError(determinedType || "RavenException", schema.error);
            }
        }
        catch (errThrowing) {
            errorToThrow = getError("RavenException", errThrowing.message, errThrowing);
        }
        finally {
            response.destroy();
        }
        throw errorToThrow;
    }
    static _getConflictError(schema, json) {
        if (schema.type.includes("DocumentConflictException")) {
            return getError("DocumentConflictException", schema.message, null, { json });
        }
        return getError("ConcurrencyException", schema.message);
    }
    static _getType(typeAsString) {
        if ("System.TimeoutException" === typeAsString) {
            return "TimeoutException";
        }
        const prefix = "Raven.Client.Exceptions.";
        if (typeAsString && typeAsString.startsWith(prefix)) {
            const exceptionName = typeAsString.substring(prefix.length);
            if (exceptionName.indexOf(".") !== -1) {
                const tokens = exceptionName.split(".");
                return tokens[tokens.length - 1];
            }
            return exceptionName;
        }
        else {
            return null;
        }
    }
}
ExceptionDispatcher._jsonSerializer = Serializer_1.JsonSerializer.getDefaultForCommandPayload();
exports.ExceptionDispatcher = ExceptionDispatcher;
