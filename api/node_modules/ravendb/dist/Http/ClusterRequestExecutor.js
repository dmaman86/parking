"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GetClusterTopologyCommand_1 = require("../ServerWide/Commands/GetClusterTopologyCommand");
const NodeSelector_1 = require("./NodeSelector");
const os = require("os");
const BluebirdPromise = require("bluebird");
const semaphore = require("semaphore");
const LogUtil_1 = require("../Utility/LogUtil");
const RequestExecutor_1 = require("./RequestExecutor");
const __1 = require("..");
const Exceptions_1 = require("../Exceptions");
const ServerNode_1 = require("./ServerNode");
const Topology_1 = require("./Topology");
const GetTcpInfoCommand_1 = require("../ServerWide/Commands/GetTcpInfoCommand");
const SemaphoreUtil_1 = require("../Utility/SemaphoreUtil");
const log = LogUtil_1.getLogger({ module: "ClusterRequestExecutor" });
class ClusterRequestExecutor extends RequestExecutor_1.RequestExecutor {
    constructor(authOptions, conventions) {
        super(null, authOptions, conventions);
        this._clusterTopologySemaphore = semaphore();
    }
    static createForSingleNodeWithConfigurationUpdates(url, databaseName, opts) {
        return Exceptions_1.throwError("NotSupportedException");
    }
    static createForSingleNodeWithoutConfigurationUpdates(url, databaseName, opts) {
        return Exceptions_1.throwError("NotSupportedException");
    }
    static createForSingleNode(url, opts) {
        const initialUrls = [url];
        const { authOptions, documentConventions } = opts;
        const urls = this._validateUrls(initialUrls, authOptions);
        const executor = new ClusterRequestExecutor(authOptions, documentConventions || __1.DocumentConventions.defaultConventions);
        const serverNode = new ServerNode_1.ServerNode({ url });
        const topology = new Topology_1.Topology(-1, [serverNode]);
        const nodeSelector = new NodeSelector_1.NodeSelector(topology);
        executor._nodeSelector = nodeSelector;
        executor._topologyEtag = -2;
        executor._disableClientConfigurationUpdates = true;
        executor._disableTopologyUpdates = true;
        return executor;
    }
    static create(initialUrls, databaseOrOpts, opts) {
        if (typeof (databaseOrOpts) === "string") {
            return Exceptions_1.throwError("NotSupportedException");
        }
        const { authOptions, documentConventions } = (opts || databaseOrOpts) || {};
        const executor = new ClusterRequestExecutor(authOptions, documentConventions ? documentConventions : __1.DocumentConventions.defaultConventions);
        executor._disableClientConfigurationUpdates = true;
        executor._firstTopologyUpdatePromise = executor._firstTopologyUpdate(initialUrls);
        return executor;
    }
    _performHealthCheck(serverNode, nodeIndex) {
        return this.execute(new GetTcpInfoCommand_1.GetTcpInfoCommand("health-check"), null, {
            chosenNode: serverNode,
            nodeIndex,
            shouldRetry: false
        });
    }
    updateTopology(node, timeout, forceUpdate) {
        if (this._disposed) {
            return Promise.resolve(false);
        }
        const acquiredSemContext = SemaphoreUtil_1.acquireSemaphore(this._clusterTopologySemaphore, { timeout });
        const result = BluebirdPromise.resolve(acquiredSemContext.promise)
            .then(() => {
            if (this._disposed) {
                return false;
            }
            const command = new GetClusterTopologyCommand_1.GetClusterTopologyCommand();
            return this.execute(command, null, {
                chosenNode: node,
                nodeIndex: null,
                shouldRetry: false
            })
                .then(() => {
                const results = command.result;
                const members = results.topology.members;
                const nodes = Object.keys(members)
                    .reduce((reduceResult, clusterTag) => {
                    const url = members[clusterTag];
                    const serverNode = new ServerNode_1.ServerNode({ clusterTag, url });
                    return [...reduceResult, serverNode];
                }, []);
                const newTopology = new Topology_1.Topology(0, nodes);
                if (!this._nodeSelector) {
                    this._nodeSelector = new NodeSelector_1.NodeSelector(newTopology);
                    if (this._readBalanceBehavior === "FastestNode") {
                        this._nodeSelector.scheduleSpeedTest();
                    }
                }
                else if (this._nodeSelector.onUpdateTopology(newTopology, forceUpdate)) {
                    this._disposeAllFailedNodesTimers();
                    if (this._readBalanceBehavior === "FastestNode") {
                        this._nodeSelector.scheduleSpeedTest();
                    }
                }
            })
                .then(() => true);
        }, (reason) => {
            if (reason.name === "TimeoutError") {
                return false;
            }
            throw reason;
        })
            .finally(() => acquiredSemContext.dispose());
        return Promise.resolve(result);
    }
    _updateClientConfigurationAsync() {
        return Promise.resolve();
    }
    _throwExceptions(details) {
        Exceptions_1.throwError("InvalidOperationException", "Failed to retrieve cluster topology from all known nodes" + os.EOL + details);
    }
    dispose() {
        this._clusterTopologySemaphore.take(() => { });
        super.dispose();
    }
}
exports.ClusterRequestExecutor = ClusterRequestExecutor;
