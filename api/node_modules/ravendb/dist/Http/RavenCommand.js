"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StatusCode_1 = require("../Http/StatusCode");
const request = require("request-promise");
const LogUtil_1 = require("../Utility/LogUtil");
const Exceptions_1 = require("../Exceptions");
const HttpUtil_1 = require("../Utility/HttpUtil");
const Mapping_1 = require("../Mapping");
const Serializer_1 = require("../Mapping/Json/Serializer");
const log = LogUtil_1.getLogger({ module: "RavenCommand" });
class RavenCommand {
    constructor() {
        this._typedObjectMapper = Mapping_1.Mapping.getDefaultMapper();
        this._responseType = "Object";
        this._canCache = true;
        this._canCacheAggressively = true;
    }
    get responseType() {
        return this._responseType;
    }
    get canCache() {
        return this._canCache;
    }
    get canCacheAggressively() {
        return this._canCacheAggressively;
    }
    get _serializer() {
        return Serializer_1.JsonSerializer.getDefaultForCommandPayload();
    }
    setResponse(response, fromCache) {
        if (this._responseType === "Empty"
            || this._responseType === "Raw") {
            this._throwInvalidResponse();
        }
        Exceptions_1.throwError("NotSupportedException", this.constructor.name +
            " command must override the setResponse method which expects response with the following type: " +
            this._responseType);
    }
    send(requestOptions) {
        const { body, uri } = requestOptions;
        log.info(`Send command ${this.constructor.name} to ${uri}${body ? " with body " + body : ""}.`);
        return Promise.resolve(request(requestOptions));
    }
    setResponseRaw(response, body) {
        Exceptions_1.throwError("NotSupportedException", "When " + this._responseType + " is set to RAW then please override this method to handle the response.");
    }
    _throwInvalidResponse() {
        Exceptions_1.throwError("InvalidOperationException", "Response is invalid");
    }
    _urlEncode(value) {
        return encodeURIComponent(value);
    }
    static ensureIsNotNullOrEmpty(value, name) {
        if (!value) {
            Exceptions_1.throwError("InvalidArgumentException", name + " cannot be null or empty");
        }
    }
    isFailedWithNode(node) {
        return this.failedNodes
            && !!this.failedNodes.get(node);
    }
    processResponse(cache, response, url) {
        const responseEntity = response.body;
        if (!responseEntity) {
            return "Automatic";
        }
        if (this._responseType === "Empty" ||
            response.statusCode === StatusCode_1.StatusCodes.NoContent) {
            return "Automatic";
        }
        try {
            if (this._responseType === "Object") {
                const contentLength = parseInt(response.caseless.get("content-length"), 10);
                if (contentLength === 0) {
                    response.destroy();
                    return "Automatic";
                }
                const { body } = response;
                if (cache) {
                    this._cacheResponse(cache, url, response, body);
                }
                this.setResponse(body, false);
                return "Automatic";
            }
            else {
                this.setResponseRaw(response, response.body);
            }
            return "Automatic";
        }
        catch (err) {
            log.error(err, `Error processing command ${this.constructor.name} response.`);
            Exceptions_1.throwError("RavenException", `Error processing command ${this.constructor.name} response.`, err);
        }
        finally {
            response.destroy();
        }
        return "Automatic";
    }
    _cacheResponse(cache, url, response, responseJson) {
        if (!this.canCache) {
            return;
        }
        const changeVector = HttpUtil_1.getEtagHeader(response);
        if (!changeVector) {
            return;
        }
        cache.set(url, changeVector, responseJson);
    }
    _addChangeVectorIfNotNull(changeVector, req) {
        if (changeVector) {
            req.headers["If-Match"] = `"${changeVector}"`;
        }
    }
    _parseResponseDefault(response, typeInfo, knownTypes) {
        const res = this._serializer.deserialize(response);
        const resObj = this._typedObjectMapper.fromObjectLiteral(res, typeInfo, knownTypes);
        return resObj;
    }
    _getHeaders() {
        return HttpUtil_1.HeadersBuilder.create();
    }
    onResponseFailure(response) { }
}
exports.RavenCommand = RavenCommand;
