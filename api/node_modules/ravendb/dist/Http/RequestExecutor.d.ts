import * as BluebirdPromise from "bluebird";
import { ServerNode } from "./ServerNode";
import { RavenCommand } from "./RavenCommand";
import { Topology } from "./Topology";
import { NodeSelector } from "./NodeSelector";
import { IDisposable } from "../Types/Contracts";
import { IRequestAuthOptions, IAuthOptions } from "../Auth/AuthOptions";
import { ICertificate } from "../Auth/Certificate";
import { ReadBalanceBehavior } from "./ReadBalanceBehavior";
import { HttpCache } from "./HttpCache";
import { AggressiveCacheOptions } from "./AggressiveCacheOptions";
import CurrentIndexAndNode from "./CurrentIndexAndNode";
import { HttpRequestBase } from "../Primitives/Http";
import { DocumentConventions } from "../Documents/Conventions/DocumentConventions";
import { RequestPromiseOptions } from "request-promise";
import { SessionInfo } from "../Documents/Session/IDocumentSession";
export declare function getDefaultRequestOptions(): RequestPromiseOptions;
export interface ExecuteOptions<TResult> {
    chosenNode: ServerNode;
    nodeIndex: number;
    shouldRetry: boolean;
}
export interface ITopologyUpdateEvent {
    topologyJson: object;
    serverNodeUrl: string;
    requestedDatabase?: string;
    forceUpdate?: boolean;
    wasUpdated?: boolean;
}
export interface IRequestExecutorOptions {
    authOptions?: IRequestAuthOptions;
    documentConventions?: DocumentConventions;
}
export declare class NodeStatus implements IDisposable {
    private _nodeStatusCallback;
    private _timerPeriodInMs;
    readonly nodeIndex: number;
    readonly node: ServerNode;
    private _timer;
    constructor(nodeIndex: number, node: ServerNode, nodeStatusCallback: (nodeStatus: NodeStatus) => Promise<void>);
    private _nextTimerPeriod();
    startTimer(): void;
    updateTimer(): void;
    dispose(): void;
}
export declare class RequestExecutor implements IDisposable {
    private _log;
    static readonly CLIENT_VERSION: string;
    private _updateDatabaseTopologySemaphore;
    private _updateClientConfigurationSemaphore;
    private static _failureCheckOperation;
    private _failedNodesTimers;
    protected _databaseName: string;
    protected _certificate: ICertificate;
    private _lastReturnedResponse;
    protected _readBalanceBehavior: ReadBalanceBehavior;
    private _cache;
    private _topologyTakenFromNode;
    agressiveCaching: AggressiveCacheOptions;
    private _updateTopologyTimer;
    protected _nodeSelector: NodeSelector;
    numberOfServerRequests: number;
    protected _disposed: boolean;
    protected _firstTopologyUpdatePromise: BluebirdPromise<void>;
    protected _lastKnownUrls: string[];
    protected _clientConfigurationEtag: number;
    protected _topologyEtag: number;
    private _conventions;
    private _authOptions;
    protected _disableTopologyUpdates: boolean;
    protected _disableClientConfigurationUpdates: boolean;
    static requestPostProcessor: (req: HttpRequestBase) => void;
    getTopologyEtag(): number;
    readonly conventions: DocumentConventions;
    getClientConfigurationEtag(): number;
    readonly cache: HttpCache;
    readonly disposed: boolean;
    getUrl(): string;
    getTopology(): Topology;
    getTopologyNodes(): ServerNode[];
    protected constructor(database: string, authOptions: IRequestAuthOptions, conventions: DocumentConventions);
    static create(intialUrls: string[], database: string): RequestExecutor;
    static create(intialUrls: string[], database: string, opts?: IRequestExecutorOptions): RequestExecutor;
    static createForSingleNodeWithConfigurationUpdates(url: string, database: string, opts: IRequestExecutorOptions): RequestExecutor;
    static createForSingleNodeWithoutConfigurationUpdates(url: string, database: string, opts: IRequestExecutorOptions): RequestExecutor;
    private _ensureNodeSelector();
    getPreferredNode(): Promise<CurrentIndexAndNode>;
    getNodeBySessionId(sessionId: number): Promise<CurrentIndexAndNode>;
    getFastestNode(): Promise<CurrentIndexAndNode>;
    protected _updateClientConfiguration(): PromiseLike<void>;
    updateTopology(node: ServerNode, timeout: number, forceUpdate?: boolean): Promise<boolean>;
    protected static _validateUrls(initialUrls: string[], authOptions: IAuthOptions): any[];
    private _initializeUpdateTopologyTimer();
    private _updateTopologyCallback();
    protected _firstTopologyUpdate(inputUrls: string[]): BluebirdPromise<void>;
    protected _throwExceptions(details: string): void;
    protected _disposeAllFailedNodesTimers(): void;
    chooseNodeForRequest<TResult>(cmd: RavenCommand<TResult>, sessionInfo: SessionInfo): CurrentIndexAndNode;
    execute<TResult>(command: RavenCommand<TResult>): Promise<void>;
    execute<TResult>(command: RavenCommand<TResult>, sessionInfo?: SessionInfo): Promise<void>;
    execute<TResult>(command: RavenCommand<TResult>, sessionInfo?: SessionInfo, options?: ExecuteOptions<TResult>): Promise<void>;
    private _unlikelyExecute<TResult>(command, topologyUpdate, sessionInfo);
    private _getFromCache<TResult>(command, url, cachedItemMetadataCallback);
    private _executeOnSpecificNode<TResult>(command, sessionInfo?, options?);
    private _throwFailedToContactAllNodes<TResult>(command, req, e, timeoutException);
    inSpeedTestPhase(): boolean;
    private _handleUnsuccessfulResponse<TResult>(chosenNode, nodeIndex, command, req, response, url, sessionInfo, shouldRetry);
    private _executeOnAllToFigureOutTheFastest<TResult>(chosenNode, command);
    private _shouldExecuteOnAll<TResult>(chosenNode, command);
    private _handleServerDown<TResult>(url, chosenNode, nodeIndex, command, req, response, error, sessionInfo);
    private static _addFailedResponseToCommand<TResult>(chosenNode, command, req, response, e);
    private _createRequest<TResult>(node, command);
    private static _handleConflict(response);
    private _spawnHealthChecks(chosenNode, nodeIndex);
    private _checkNodeStatusCallback(nodeStatus);
    protected _performHealthCheck(serverNode: ServerNode, nodeIndex: number): Promise<void>;
    dispose(): void;
}
