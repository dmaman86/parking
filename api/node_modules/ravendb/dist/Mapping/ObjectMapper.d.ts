import { ObjectTypeDescriptor } from "../Types";
export interface TypeInfo {
    typeName?: string;
    nestedTypes?: NestedTypes;
}
export interface NestedTypes {
    [propertyPath: string]: string;
}
export interface ITypesAwareObjectMapper {
    fromObjectLiteral<TResult extends object>(raw: object, typeInfo?: TypeInfo): TResult;
    toObjectLiteral<TFrom extends object>(obj: TFrom, typeInfo?: (typeInfo: TypeInfo) => void): object;
}
export declare class ObjectKeysTransform {
    static camelCase(obj: object, recursive?: boolean): any;
}
export declare class TypesAwareObjectMapper implements ITypesAwareObjectMapper {
    private _knownTypes;
    private _dateFormat;
    private _throwMappingErrors;
    constructor(opts?: TypesAwareJsonObjectMapperOptions);
    throwMappingErrors: boolean;
    registerType(classCtorOrTypeDescriptor: ObjectTypeDescriptor): this;
    fromObjectLiteral<TResult extends object>(rawResult: object, typeInfo?: TypeInfo): TResult;
    fromObjectLiteral<TResult extends object>(rawResult: object, typeInfo?: TypeInfo, knownTypes?: Map<string, ObjectTypeDescriptor>): TResult;
    private _applyNestedTypes<TResult>(obj, nestedTypes?, knownTypes?);
    toObjectLiteral<TFrom extends object>(obj: TFrom): object;
    toObjectLiteral<TFrom extends object>(obj: TFrom, typeInfoCallback?: (typeInfo: TypeInfo) => void): object;
    toObjectLiteral<TFrom extends object>(obj: TFrom, typeInfoCallback?: (typeInfo: TypeInfo) => void, knownTypes?: Map<string, ObjectTypeDescriptor>): object;
    private _getFieldContext(parent, objPath);
    private _getFieldContextsForMapEntries(mapFieldVal, fieldsPathTail);
    private _getFieldContextsForSetElements(setFieldVal, fieldsPathTail);
    private _getFieldContextsForArrayElements(fieldVal, fieldsPathTail);
    private _flattenFieldContexts(arr);
    private _applyTypeToNestedProperty(fieldTypeName, fieldContext, knownTypes);
    private _instantiateObject<TResult>(typeName, rawValue, ctorOrTypeDescriptor);
    private _getKnownType(typeName, knownTypes);
    private _createEmptyObject<TResult>(ctor);
    private _makeObjectLiteral(obj, objPathPrefix, typeInfoCallback, knownTypes);
}
export interface TypesAwareJsonObjectMapperOptions {
    dateFormat?: string;
    knownTypes?: Map<string, ObjectTypeDescriptor>;
}
