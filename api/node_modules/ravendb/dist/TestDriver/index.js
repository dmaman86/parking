"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BluebirdPromise = require("bluebird");
const child_process_1 = require("child_process");
const os = require("os");
const verror_1 = require("verror");
const Constants_1 = require("../Constants");
const DocumentStore_1 = require("../Documents/DocumentStore");
const GetStatisticsOperation_1 = require("../Documents/Operations/GetStatisticsOperation");
const Exceptions_1 = require("../Exceptions");
const CreateDatabaseOperation_1 = require("../ServerWide/Operations/CreateDatabaseOperation");
const DeleteDatabasesOperation_1 = require("../ServerWide/Operations/DeleteDatabasesOperation");
const LogUtil_1 = require("../Utility/LogUtil");
const RavenServerRunner_1 = require("./RavenServerRunner");
const TypeUtil_1 = require("../Utility/TypeUtil");
const log = LogUtil_1.getLogger({ module: "TestDriver" });
class RavenTestDriver {
    constructor(locator, securedLocator) {
        this._documentStores = new Set();
        this._disposed = false;
        this._customizeDbRecord = TypeUtil_1.TypeUtil.NOOP;
        this._locator = locator;
        this._securedLocator = securedLocator;
    }
    isDisposed() {
        return this._disposed;
    }
    getSecuredDocumentStore(database) {
        return this.getDocumentStore(database, true, null);
    }
    set customizeDbRecord(customizeDbRecord) {
        this._customizeDbRecord = customizeDbRecord;
    }
    get customizeDbRecord() {
        return this._customizeDbRecord;
    }
    getDocumentStore(database = "test_db", secured = false, waitForIndexingTimeoutInMs = null) {
        const databaseName = database + "_" + (++RavenTestDriver._index);
        log.info(`getDocumentStore for db ${database}.`);
        let documentStore;
        return Promise.resolve()
            .then(() => {
            if (!this._getGlobalServer(secured)) {
                return this._runServer(secured);
            }
        })
            .then(() => {
            documentStore = this._getGlobalServer(secured);
            const databaseRecord = { databaseName };
            if (this._customizeDbRecord) {
                this._customizeDbRecord(databaseRecord);
            }
            const createDatabaseOperation = new CreateDatabaseOperation_1.CreateDatabaseOperation(databaseRecord);
            return documentStore.maintenance.server.send(createDatabaseOperation);
        })
            .then(createDatabaseResult => {
            const store = new DocumentStore_1.DocumentStore(documentStore.urls, databaseName);
            if (secured) {
                store.authOptions = this._securedLocator.getClientAuthOptions();
            }
            store.initialize();
            store.once("afterDispose", (callback) => {
                if (!this._documentStores.has(store)) {
                    callback();
                    return;
                }
                return BluebirdPromise.resolve()
                    .then(() => {
                    return store.maintenance.server.send(new DeleteDatabasesOperation_1.DeleteDatabasesOperation({
                        databaseNames: [store.database],
                        hardDelete: true
                    }));
                })
                    .tap((deleteResult) => {
                    log.info(`Database ${store.database} deleted.`);
                })
                    .catch(err => {
                    if (err.name === "DatabaseDoesNotExistException"
                        || err.name === "NoLeaderException") {
                        return;
                    }
                    Exceptions_1.throwError("TestDriverTearDownError", `Error deleting database ${store.database}.`, err);
                })
                    .finally(() => callback());
            });
            return Promise.resolve()
                .then(() => this._setupDatabase(store))
                .then(() => {
                if (!TypeUtil_1.TypeUtil.isNullOrUndefined(waitForIndexingTimeoutInMs)) {
                    return this.waitForIndexing(store);
                }
            })
                .then(() => this._documentStores.add(store))
                .then(() => store);
        });
    }
    _setupDatabase(documentStore) {
        return Promise.resolve();
    }
    _runServer(secured) {
        log.info("Run global server");
        const process = RavenServerRunner_1.RavenServerRunner.run(secured ? this._securedLocator : this._locator);
        this._setGlobalServerProcess(secured, process);
        process.once("exit", (code, signal) => {
            log.info("Exiting.");
        });
        const scrapServerUrl = () => {
            const SERVER_URL_REGEX = /Server available on:\s*(\S+)\s*$/m;
            const serverProcess = this._getGlobalProcess(secured);
            let serverOutput = "";
            const result = new BluebirdPromise((resolve, reject) => {
                serverProcess.stdout
                    .on("data", (chunk) => {
                    serverOutput += chunk;
                    try {
                        const regexMatch = serverOutput.match(SERVER_URL_REGEX);
                        if (!regexMatch) {
                            return;
                        }
                        const data = regexMatch[1];
                        if (data) {
                            resolve(data);
                        }
                    }
                    catch (err) {
                        reject(err);
                    }
                })
                    .on("error", (err) => reject(err));
            });
            return result
                .timeout(10000)
                .catch((err) => {
                Exceptions_1.throwError("UrlScrappingError", "Error scrapping URL from server process output: "
                    + os.EOL + serverOutput, err);
            });
        };
        return Promise.resolve()
            .then(() => scrapServerUrl())
            .catch((err) => {
            try {
                process.kill("SIGKILL");
            }
            catch (processKillErr) {
                log.error(processKillErr);
            }
            Exceptions_1.throwError("InvalidOperationException", "Unable to start server.", err);
        })
            .then((serverUrl) => {
            const store = new DocumentStore_1.DocumentStore([serverUrl], "test.manager");
            store.conventions.disableTopologyUpdates = true;
            if (secured) {
                RavenTestDriver._globalSecuredServer = store;
                store.authOptions = this._securedLocator.getClientAuthOptions();
            }
            else {
                RavenTestDriver._globalServer = store;
            }
            return store.initialize();
        });
    }
    static _killGlobalServerProcess(secured) {
        let p;
        if (secured) {
            p = RavenTestDriver._globalSecuredServerProcess;
            RavenTestDriver._globalSecuredServerProcess = null;
        }
        else {
            p = RavenTestDriver._globalServerProcess;
            RavenTestDriver._globalServerProcess = null;
        }
        if (p && !p.killed) {
            log.info("Kill global server");
            try {
                p.kill();
            }
            catch (err) {
                log.error(err);
            }
        }
    }
    _getGlobalServer(secured) {
        return secured ? RavenTestDriver._globalSecuredServer : RavenTestDriver._globalServer;
    }
    _getGlobalProcess(secured) {
        return secured ? RavenTestDriver._globalSecuredServerProcess : RavenTestDriver._globalServerProcess;
    }
    _setGlobalServerProcess(secured, p) {
        if (secured) {
            RavenTestDriver._globalSecuredServerProcess = p;
        }
        else {
            RavenTestDriver._globalServerProcess = p;
        }
    }
    waitForIndexing(store, database, timeout, throwOnIndexErrors = true) {
        const admin = store.maintenance.forDatabase(database);
        if (!timeout) {
            timeout = 60 * 1000;
        }
        const isIndexingDone = () => {
            return Promise.resolve()
                .then(() => admin.send(new GetStatisticsOperation_1.GetStatisticsOperation()))
                .then((dbStats) => {
                const indexes = dbStats.indexes.filter(x => x.state !== "Disabled");
                const errIndexes = indexes.filter(x => x.state === "Error");
                if (errIndexes.length && throwOnIndexErrors) {
                    Exceptions_1.throwError("IndexInvalidException", `The following indexes are erroneous: ${errIndexes.map(x => x.name).join(", ")}`);
                }
                return indexes.every(x => !x.isStale
                    && !x.name.startsWith(Constants_1.CONSTANTS.Documents.Indexing.SIDE_BY_SIDE_INDEX_NAME_PREFIX));
            });
        };
        const pollIndexingStatus = () => {
            log.info("Waiting for indexing...");
            return BluebirdPromise.resolve()
                .then(() => isIndexingDone())
                .then(indexingDone => {
                if (!indexingDone) {
                    return BluebirdPromise.resolve()
                        .delay(100)
                        .then(() => pollIndexingStatus());
                }
                else {
                    log.info("Done waiting for indexing.");
                }
            });
        };
        const result = BluebirdPromise.resolve(pollIndexingStatus())
            .timeout(timeout)
            .tapCatch((err) => {
            log.warn(err, "Wait for indexing timeout.");
        });
        return Promise.resolve(result);
    }
    waitForUserToContinueTheTest(store) {
    }
    _openBrowser(url) {
        console.log(url);
        if (os.platform() === "win32") {
            child_process_1.spawn("powershell.exe", ["-c", `start-process ${url}`], {
                detached: true
            });
        }
        else {
            child_process_1.spawn("xdg-open", [url], {
                detached: true
            });
        }
    }
    dispose() {
        log.info("Dispose.");
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        const STORE_DISPOSAL_TIMEOUT = 10000;
        const storeDisposalPromises = [...this._documentStores].map((store) => {
            return Promise.resolve()
                .then(() => {
                const result = new BluebirdPromise((resolve) => {
                    store.once("executorsDisposed", () => {
                        resolve();
                    });
                })
                    .timeout(STORE_DISPOSAL_TIMEOUT)
                    .then(() => null);
                store.dispose();
                return result;
            })
                .catch((err) => Exceptions_1.getError("TestDriverTeardownError", "Error disposing document store", err));
        });
        BluebirdPromise.all(storeDisposalPromises)
            .then((errors) => {
            const anyErrors = errors.filter(x => !!x);
            if (anyErrors.length) {
                throw new verror_1.MultiError(anyErrors);
            }
        })
            .then(() => {
            if (RavenTestDriver._globalSecuredServer) {
                RavenTestDriver._globalSecuredServer.dispose();
            }
            if (RavenTestDriver._globalServer) {
                RavenTestDriver._globalServer.dispose();
            }
        })
            .finally(() => {
            RavenTestDriver._killGlobalServerProcess(true);
            RavenTestDriver._killGlobalServerProcess(false);
        });
    }
}
RavenTestDriver._index = 0;
exports.RavenTestDriver = RavenTestDriver;
