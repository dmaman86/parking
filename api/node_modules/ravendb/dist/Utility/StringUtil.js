"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const XRegExp = require("xregexp");
const TypeUtil_1 = require("./TypeUtil");
const Exceptions_1 = require("../Exceptions");
class StringUtil {
    static format(s, vars, ...varsArray) {
        if (TypeUtil_1.TypeUtil.isObject(vars)) {
            return s.replace(/\{([\w\d\-]+)\}/g, (match, placeholder) => ((placeholder in vars) ? vars[placeholder] : "").toString());
        }
        const inputVars = [vars].concat(varsArray);
        return s.replace(/\{([\d]+)\}/g, (match, placeholder) => {
            const value = inputVars[parseInt(placeholder, 10)];
            return (TypeUtil_1.TypeUtil.isNullOrUndefined(value) ? "" : value).toString();
        });
    }
    static validateDBName(dbName) {
        if (TypeUtil_1.TypeUtil.isNullOrUndefined(dbName) || !dbName) {
            Exceptions_1.throwError("InvalidOperationException", "Empty name is not valid");
        }
        if (!/^[A-Za-z0-9_\-\.]+$/.test(dbName)) {
            Exceptions_1.throwError("InvalidOperationException", `Database name can only contain only A-Z, a-z, "_", "." or "-"`);
        }
    }
    static escapeIfNecessary(field) {
        if (!field) {
            return field;
        }
        let escape = false;
        for (let i = 0; i < field.length; i++) {
            const c = field[i];
            if (i === 0) {
                if (!this.isLetter(c) && ["_", "@"].indexOf(c) === -1) {
                    escape = true;
                    break;
                }
                continue;
            }
            if (!this.isLetterOrDigit(c) && ["_", "@", ".", "[", "]"].indexOf(c) === -1) {
                escape = true;
                break;
            }
        }
        if (escape) {
            return `'${field}'`;
        }
        return field;
    }
    static capitalize(s) {
        return s.charAt(0).toUpperCase() + s.substring(1);
    }
    static uncapitalize(s) {
        return s.charAt(0).toLowerCase() + s.substring(1);
    }
    static isCharacter(character) {
        return character && (1 === character.length);
    }
    static isDigit(character) {
        return this.isCharacter(character)
            && this.digitRe.test(character);
    }
    static isLetter(character) {
        return this.isCharacter(character)
            && this.letterRe.test(character);
    }
    static isLetterOrDigit(character) {
        return this.isLetter(character)
            || this.isDigit(character);
    }
    static isNullOrWhiteSpace(s) {
        return !(s || "").trim().length;
    }
}
StringUtil.letterRe = XRegExp("^\\p{L}$");
StringUtil.digitRe = /\d/;
exports.StringUtil = StringUtil;
